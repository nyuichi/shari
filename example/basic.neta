infix = : 50 := eq
nofix ⊤ := top
infixr ∧ : 35 := and
infixr → : 25 := imp
nofix ⊥ := bot
infixr ∨ : 30 := or
prefix ¬ : 40 := not
infix ↔ : 20 := iff

infix ∈ : 50 := mem
infix ∉ : 50 := notmem
infix ⊆ : 50 := subseteq
infixl ∩ : 70 := cap
infixl ∪ : 65 := cup
infix \ : 70 := setminus
nofix ∅ := empty
infixr ⇒ : 25 := fun

-- the characteristic of the diagonal mono δ : u → u × u
constant eq : u → u → Prop

-- Hilbert's ε-operator a.k.a. global choice
-- Assuming the standard semantics (with inhabited domains), we can put any formals in prenex normal form:
-- ((∀ x, φ) → ψ) ≡ (∃ x, φ → ψ)  where  x ∉ FV ψ
constant choice : (u → Prop) → Prop

-- This is definitionally equal to any term of the unit type by the eta rule.
constant star : unit

/-
This introduces a constant `top` and:
axiom top_spec : top = (star = star)
-/
def top : Prop := star = star
def and (φ ψ : Prop) : Prop := ⟨φ, ψ⟩ = ⟨⊤, ⊤⟩
def imp (φ ψ : Prop) : Prop := φ = φ ∧ ψ   -- Recall [x = x ∧ y] means [x ≤ y] in the preorder canonically induced by a lattice structure.
def forall (P : u → Prop) : Prop := P = (λ x, ⊤)
def bot : Prop := ∀ ξ, ξ
def or (φ ψ : Prop) : Prop := ∀ ξ, (φ → ξ) ∧ (ψ → ξ) → ξ
def exists (P : u → Prop) : Prop := ∀ ξ, (∀ x, P x → ξ) → ξ
def not (φ : Prop) : Prop := φ → ⊥
def iff (φ ψ : Prop) : Prop := (φ → ψ) ∧ (ψ → φ)
def uexists (P : u → Prop) : Prop := ∃ x, P x ∧ (∀ y, P y → x = y)

def default : u := choice (λ x, ⊤)

/-
-- type abbreviation (does not introduce a new opaque type)
type Set u := u → Prop

def mem (x : u) (A : Set u) : Prop := A x
def notmem (x : u) (A : Set u) : Prop := ¬ (x ∈ A)
def sep (A : Set u) (φ : u → Prop) : Set u := λ x, x ∈ A ∧ φ x
def subseteq (A B : Set u) : Prop := ∀ x, x ∈ A → x ∈ B
def cap (A B : Set u) : Set u := { x | x ∈ A ∧ x ∈ B }
def cup (A B : Set u) : Set u := { x | x ∈ A ∨ x ∈ B }
def bigcup (C : Set (Set u)) : Set u := { x | ∃ A ∈ C, x ∈ A }
def powerset (A : Set u) : Set (Set u) := { X | X ⊂ A }
def univ : Set u := λ x, ⊤
def empty : Set u := λ x, ⊥
def setminus (A B : Set u) : Set u := { x | x ∈ A ∧ x ∉ B }
def prod (A : Set u) (B : Set v) : Set (u × v) := { ⟨x, y⟩ | x ∈ A ∧ y ∈ B }
def sum (A : Set u) (B : Set v) : Set (Set u × Set v) := { ⟨{x}, ∅⟩ | x ∈ B } ∪ { ⟨∅, {y}⟩ | y ∈ B }
def fun (A : Set u) (B : Set v) : Set (Set (u × v)) := { f ⊆ A × B | ∀ (x ∈ A), ∃! (y ∈ B), ⟨x, y⟩ ∈ f }
def app [Inhabited v] (f : Set (u × v)) (x : u) : v := choice (λ y, ⟨x, y⟩ ∈ f)
def id (A : Set u) : Set (Set (u × v)) := { ⟨x, x⟩ | x ∈ A }

type NumericDomain := (Base → Base) → Base → Base

def zero : NumericDomain := λ f x, x
def succ (n : NumericDomain) : NumericDomain := λ f x, f (n f x) x
def ℕ : Set NumericDomain := λ n, ∀ P, P zero → (∀ x, P x → P (succ x)) → P n

def topology (X : Set u) : Set (Set (Set u)) := { C | X ∈ C ∧ (∀ (U ∈ C) (V ∈ C), U ∩ V ∈ C) ∧ (∀ B ⊆ C, bigcup B ∈ C) }

/-
# Primitive rules

We assume contexts are sets.

h : [Γ ▸ Φ ⊢ φ]
-------------------------
h : [Γ, x : τ ▸ Φ, ψ ⊢ φ]

h : [Γ ▸ Φ ⊢ φ]
------------------
h : [Γ ▸ Φ, ψ ⊢ φ]

----------------------
assume φ : [Γ ▸ φ ⊢ φ]

--------------------------
eq_intro t : [Γ ▸ ⊢ t = t]

h₁ : [Γ ▸ Φ ⊢ t = s]  h₂ : [Γ ▸ Ψ ⊢ C t]
---------------------------------------- [indiscernibility of identicals]
eq_elim C h₁ h₂ : [Γ ∪ Δ ▸ Φ ∪ Ψ ⊢ C s]

h₁ : [Γ ▸ Φ, φ ⊢ ψ]  h₂ : [Γ ▸ Ψ, ψ ⊢ φ]
---------------------------------------- [(external) propositional extensionality]
prop_ext h₁ h₂ : [Γ ∪ Δ ▸ Φ ∪ Ψ ⊢ φ = ψ]

h : [Γ, x : τ ▸ Φ ⊢ t₁ = t₂]
--------------------------------------------- (x ∉ FV Φ) [(external) function extensionality]
fun_ext x h : [Γ ▸ Φ ⊢ (λ x, t₁) = (λ x, t₂)]

# Metatheorem

h : [Γ, x : τ ▸ Φ ⊢ φ]
-----------------------------------
subst x t h : [Γ ▸ [t/x]Φ ⊢ [t/x]φ]

# Derived rules

h : [Γ ▸ Φ, φ ⊢ ψ]
-----------------------------
imp_intro h : [Γ ▸ Φ ⊢ φ → ψ]

h₁ : [Γ ▸ Φ ⊢ φ → ψ]  h₂ : [Δ ▸ Ψ ⊢ φ]
---------------------------------------
imp_elim h₁ h₂ : [Γ ∪ Δ ▸ Φ ∪ Ψ ⊢ ψ]

h : [Γ, x : τ ▸ Φ ⊢ φ]
----------------------------------- (x ∉ FV Φ)
forall_intro x h : [Γ ▸ Φ ⊢ ∀ x, φ]

h : [Γ ▸ Φ ⊢ ∀ x, φ]
----------------------------------
forall_elim t h : [Γ ▸ Φ ⊢ [t/x]φ]
-/

/-
meta constant assume : Term → Fact
meta constant eq_intro : Term → Fact
meta constant eq_elim : Term → Fact → Fact → Fact
meta constant prop_ext : Fact → Fact → Fact
meta constant fun_ext : Term → Fact → Fact

meta constant subst : Term → Term → Fact → Fact

meta constant imp_intro : Fact → Fact
meta constant imp_elim : Fact → Fact → Fact
meta constant forall_intro : Term → Fact → Fact
meta constant forall_elim : Term → Fact → Fact
-/

/-
Proof is done by constructing in the meta stage an object of the Fact type whose judgement has the form of [▸ ⊢ φ] when the target formula is φ.

After the symbol `:=` a meta expression constructing the proof object (= Fact) follows.

This `prop` block introduces a new meta object `eq_refl : Fact`.
-/
prop eq_refl : ∀ t, t = t :=
forall_intro `t (eq_intro `t)

prop eq_elim : ∀ t s C, t = s → C t → C s :=
forall_intro `t (forall_intro `s (forall_intro `C (imp_intro (imp_intro (eq_elim `C (assume `(t = s)) (assume `(C t)))))))

/-
`{ .. }` syntax is a construct in the meta stage for tactical reasoning.
-/
prop eq_symm : ∀ t s, t = s → s = t := {
  fix t s,
  assume t = s,
  have t = s → t = t → s = t ..(1) := {
    assume t = s,
    assume t = t,
    have 
    apply eq_elim where C := (λ x, x = t),
  },
  show s = t := {
    apply (1),
    assumption,
    apply eq_refl
  },
}

prop eq_trans : ∀ t s u, t = s → s = u → t = u := {
  fix t s u,
  assume t = s,
  assume s = u,
  apply eq_elim where C := (λ x, t = x),
  assumption,
  assumption,
}

prop prod_eq : ∀ t₁ t₂ s₁ s₂, t₁ = t₂ → s₁ = s₂ → ⟨t₁, s₁⟩ = ⟨t₂, s₂⟩ := {
  fix t₁ t₂ s₁ s₂,
  assume t₁ = t₂,
  assume s₁ = s₂,
  have ⟨t₁, s₁⟩ = ⟨t₂, s₁⟩, from eq_elim (λ x, ⟨t₁, s₁⟩ = ⟨x, s₁⟩) (assume (t₁ = t₂)) (eq_intro ⟨t₁, s₁⟩),
  have ⟨t₂, s₁⟩ = ⟨t₂, s₂⟩, from eq_elim (λ x, ⟨t₂, s₁⟩ = ⟨t₂, x⟩) (assume (s₁ = s₂)) (eq_intro ⟨t₂, s₁⟩),
  show ⟨t₁, s₁⟩ = ⟨t₂, s₂⟩, {
    apply eq_trans,
    assumption ⟪⟨t₁, s₁⟩ = ⟨t₂, s₁⟩⟫,
    assumption,
  }
}

class Inhabited α :=
(prop inhabited : ∃ (x : α), ⊤)

instance [Inhabited β] : Inhabited (α → β) :=
(prop inhabited := {
  show ∃ (x : α → β), ⊤,
  obtain b from ⟪∃ (x : β), ⊤⟫,
  construction (λ _, b),
  trivial,
})

instance [Inhabited α] [Inhabited β] : Inhabited (α × β) :=
(prop inhabited := {
  show ∃ (x : α × β), ⊤,
  obtain (a : α) from ⟪∃ (x : α), ⊤⟫,
  obtain (b : β) from ⟪∃ (x : β), ⊤⟫,
  construction ⟨a, b⟩,
  trivial,
})

instance : Inhabited Unit :=
(prop inhabited := {
  construction star,
  trivial,
})

def inhabited (s : Set α) : Prop := ∃ a, a ∈ s

/-
Our standard model is ε-topos.
-/
const choice [Inhabited α] : (α → Prop) → α

axiom choice_spec [Inhabited α] : ∀ (P : α → Prop), inhabited P → P (choice P)

prop ac [Inhabited β] : ∀ (P : α → β → Prop), (∀ x, ∃ y, P x y) → ∃ f, ∀ x, P x (f x) := {
  fix P,
  assume ∀ x, ∃ y, P x y,
  construction λ x, choice (P x),
  show ∀ x, P x (choice (P x)),
  fix x,
  show P x (P x (choice (P x))),
  have inhabited (P x) → (P x (choice (P x))) := by apply choice_spec,
  have inhabited (P x) := {
    show ∃ y, y ∈ P x,
    show ∃ y, P x y,
    apply ⟪∀ x, ∃ y, P x y⟫,
  },
  apply inhabited (P x) → (P x (choice (P x))),
  assumption,
}

prop prop_ext : ∀ φ₁ φ₂, (φ₁ ↔ φ₂) → (φ₁ = φ₂) := by sorry
prop fun_ext : ∀ f₁ f₂, (∀ x, f₁ x = f₂ x) → (f₁ = f₂) := by sorry

def fst (p : α × β) : α := p.0
def snd (p : α × β) : β := p.1
def pair (a : α) (b : β) := ⟨a, b⟩

class Subtype β α :=
(pred : β → Prop)
(rep : α → β)
(prop inj : ∀ a₁ a₂, rep a₁ = rep a₂ → a₁ = a₂)
(prop im : ∀ x, pred x → ∃ a, rep a = x)

/-
This automatically defines a class instance [Subtype Unit Void].
-/
subtype Void := { x : Set Unit | ⊥ }

class Abs β α [Subtype β α] [Inhabited α] :=
(abs : β → α := λ b, choice (λ a, rep a = b))

def inv_image (f : α → β) (V : Set β) : Set α := λ a, V (f a)
def counit (a : α) : Set (Set α) := λ f, f a

/-
See [SGL, Ch IV, Sec 5]
-/
subtype Sum α β := { p : Set (Set α × Set β) | counit p = inv_image (λ x, ⟨ inv_image counit (inv_image (inv_image (λ p, p.0)) x), inv_image counit (inv_image (inv_image (λ p, p.1)) x) ⟩) p }
-/