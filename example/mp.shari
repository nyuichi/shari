/-
inductive Type
| compound String (List Type)
| fvar Name
| mvar Name

inductive Term
| bvar ℕ
| fvar Name Type
| abs Name Type Term
| app Term Term
| const Name Type
| mvar Name Type
-/

meta type Prop

meta constant eq : α → α → Prop

infix = : 50 := eq

meta constant fact_target : Fact → Term

/-
h: [Γ ▸ Φ ⊢ φ]
------------------------
h: [Γ, x : τ ▸ Φ, ψ ⊢ φ]

h: [Γ ▸ Φ ⊢ φ]
-----------------
h: [Γ ▸ Φ, ψ ⊢ φ]

---------------------
assume φ: [Γ ▸ φ ⊢ φ]

-------------------------
eq_intro t: [Γ ▸ ⊢ t = t]

h₁: [Γ ▸ Φ ⊢ t = s]  h₂: [Γ ▸ Ψ ⊢ C t]
--------------------------------------
eq_elim C h₁ h₂: [Γ ∪ Δ ▸ Φ ∪ Ψ ⊢ C s]

h₁: [Γ ▸ Φ, φ ⊢ ψ]  h₂: [Γ ▸ Ψ, ψ ⊢ φ]
---------------------------------------
prop_ext h₁ h₂: [Γ ∪ Δ ▸ Φ ∪ Ψ ⊢ φ = ψ]

h: [Γ, x : τ ▸ Φ ⊢ t₁ = t₂]
------------------------------------------ (x ∉ FV Φ)
fun_ext h: [Γ ▸ Φ ⊢ (λ x, t₁) = (λ x, t₂)]
-/
meta constant assume : Term → Fact
meta constant eq_intro : Term → Fact
meta constant eq_elim : Term → Fact → Fact → Fact
meta constant prop_ext : Fact → Fact → Fact
meta constant fun_ext : Term → Fact → Fact

meta def Type.mk_prop : Type := Type.compound "Prop" []

meta def mk_eq (t₁ t₂ : Term) : Term :=
let ty := get_type t₁,
let const_eq := Term.const (Name.str "eq") (Type.compound "→" [ty, Type.compound "→" [ty, Type.mk_prop]]),
Term.app (Term.app const_eq t₁) t₂

meta def eq_trans (h₁ h₂ : Fact) : Fact :=
let target := fact_target h₁,
let t₁ := match target {
  Term.App (Term.App (Term.Const (Name.str "eq") _) t₁) _ := t₁,
  _ := failwith "target is not identity",
},
let ty := get_type t₁,
let f := Term.Abs (Name.mk_str "x") ty (mk_eq t₁ (Term.bvar 0 ty)),
eq_elim f h₂ h₁

meta def eq_symm (h : fact) : fact :=
let target := fact_target h,
let `(?t₁ = ?_) := target,
let C := typecheck `(λ x, x = ?t₁),
eq_elim C h (eq_intro t₁)

meta def eq_symm (h : fact) : fact :=
let target := fact_target h,
let `(?t₁ = ?_) := target,
let C := typecheck `(λ x, x = ?t₁),
eq_elim C h (eq_intro t₁)

lemma eq_symm (t₁ t₂ : α) ▶ (h : t₁ = t₂) ⊢ t₂ = t₁ :=
eq_elim (λ x, x = t₁) h (eq_refl t₁)


def top : Prop := (λ (p : Prop), p) = (λ p, p)

notation `⊤` := top

def and (p₁ p₂ : Prop) : Prop := (λ P : Prop → Prop → Prop, P ⊤ ⊤) = (λ P, P p₁ p₂)

infixr ` ∧ ` : 35 := and

def imp (p₁ p₂ : Prop) : Prop := p₁ = p₁ ∧ p₂

infixr ` → ` : 25 := imp

def forall (P : α → Prop) : Prop := P = λ x, ⊤

-- notation `∀ x, p` := forall (λ x, p)

meta def top_intro (Γ : list (name × type)) (Φ : list term) : fact :=
eq_intro Γ Φ `(λ x, x) `(Prop → Prop)

lemma top_intro ⊢ ⊤ :=
eq_intro (λ (p : Prop), p)


meta constant imp_intro : Fact → Fact
meta constant imp_elim : Fact → Fact → Fact
meta constant forall_intro : Fact → Fact
meta constant forall_elim : Fact → Name → Term → Term → Fact


meta constant assume : Preproof
meta constant imp_intro : Preproof → Preproof
meta constant imp_elim : Prop → Preproof → Preproof → Preproof
meta constant forall_intro : Preproof → Preproof
meta constant forall_elim : Preproof → Preproof
meta constant eq_intro : Preproof

-- assume : Prop → Fact → Fact
lemma assume (p : Prop) ▶ (h : p) ⊢ p := h

constant lemma eq_intro (t : α) ▶ ⊢ t = t
constant lemma eq_elim (t₁ t₂ : α) (C : α → Prop) ▶ (t₁ = t₂) (C t₁) ⊢ C t₂

lemma eq_refl (t : α) ▶ ⊢ t = t :=
eq_intro t

lemma eq_subst (t₁ t₂ : α) (C : α → Prop) ▶ (h₁ : t₁ = t₂) (h₂ : C t₁) ⊢ C t₂ :=
eq_elim t₁ t₂ h₁ h₂

lemma eq_trans (t₁ t₂ t₃ : α) ▶ (h₁ : t₁ = t₂) (h₂ : t₂ = t₃) ⊢ t₁ = t₃ :=
eq_elim t₁ t₂ (λ x, t₁ = x) h₂ h₁

lemma eq_symm (t₁ t₂ : α) ▶ (h : t₁ = t₂) ⊢ t₂ = t₁ :=
eq_elim t₁ t₂ (λ x, x = t₁) h (eq_refl t₁)

lemma material_adequacy (p : Prop) ▶ (h : p = ⊤) ⊢ p :=
eq_elim ⊤ p (λ x, x) (eq_symm p ⊤ h)

lemma material_adequacy_inv (p : Prop) ▶ p ⊢ p = ⊤

lemma and_intro (p₁ p₂ : Prop) ▶ p₁, p₂ ⊢ p₁ ∧ p₂ := and_intro (λ (p : Prop), p)

def iff (p₁ p₂ : Prop) : Prop := (p → q) ∧ (q → p)

infix ` ↔ ` : 20 := iff

constant meta lemma fun_ext (f₁ f₂ : α → β) ▶ ∀ x, f₁ x = f₂ x ⊢ f₁ = f₂
constant meta lemma prop_ext (p₁ p₂ : Prop) ▶ p₁ ↔ p₂ ⊢ p₁ = p₂

meta lemma 

lemma symm : ∀ (t s : α), t = s → s = t :=



lemma mp : ∀ p q, p → (p → q) → q

inductive ℕ
| succ : ℕ → ℕ
| zero : ℕ

type Set α := α → Prop


def eq (t₁ t₂ : α) : Prop := ∀ P, P t₁ → P t₂