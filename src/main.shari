infixr → : 25 := imp
infix = : 50 := eq
nofix ⊤ := top
infixl ∧ : 35 := and
nofix ⊥ := bot
infixl ∨ : 30 := or
prefix ¬ : 40 := not
infix ↔ : 20 := iff
infix ≠ : 50 := ne

-- Leibniz equality
def eq.{u} (x : u) (y : u) : Prop := ∀ P, P x → P y

def top : Prop := ∀ φ, φ → φ
def and (φ : Prop) (ψ : Prop) : Prop := ∀ ξ, (φ → ψ → ξ) → ξ

-- The following definitions are due to Prawitz and Russell.
def bot : Prop := ∀ ξ, ξ
def or (φ : Prop) (ψ : Prop) : Prop := ∀ ξ, (φ → ξ) → (ψ → ξ) → ξ
def exists.{u} (P : u → Prop) : Prop := ∀ ξ, (∀ x, P x → ξ) → ξ

-- Other connectives
def not (φ : Prop) : Prop := φ → ⊥
def iff (φ : Prop) (ψ : Prop) : Prop := (φ → ψ) ∧ (ψ → φ)
def uexists.{u} (P : u → Prop) : Prop := ∃ x, P x ∧ (∀ y, P y → x = y)
def ne.{u} (x : u) (y : u) : Prop := ¬x = y

-- Axioms of topos (cf. [Introduction to CATEGORY THEORY and CATEGORICAL LOGIC, T. Streicher, '03])
axiom prop_ext (φ ψ : Prop) : (φ ↔ ψ) → φ = ψ
axiom fun_ext.{u, v} (f₁ f₂ : u → v) : (∀ x, f₁ x = f₂ x) → f₁ = f₂
axiom auc.{u, v} (R : u → v → Prop) : (∀ x, ∃! y, R x y) → ∃! f, ∀ x, R x (f x)

/-
 - TODO:
 - * stronger type inference. (propagate constraints among exprs)
 - * automatic insertion of forall_elim using higher-order unification
 - * field access notation
 -/
lemma tautology : ∀ φ, φ → φ := take (φ : Prop), assume φ, ⟪φ⟫
lemma top.intro : ⊤ := tautology

lemma eq.refl.{u} (m : u) : m = m := take (P : u → Prop), tautology[P m]

lemma eq.transport.{u} (m₁ m₂ : u) (P : u → Prop) : m₁ = m₂ → P m₁ → P m₂ := assume m₁ = m₂, (change ∀ P, P m₁ → P m₂, ⟪m₁ = m₂⟫)[P]
lemma eq.symm.{u} (m₁ m₂ : u) : m₁ = m₂ → m₂ = m₁ := assume m₁ = m₂, eq.transport.{u}[_, _, λ m, m = m₁] ⟪m₁ = m₂⟫ eq.refl.{u}[m₁]
lemma eq.trans.{u} (m₁ m₂ m₃ : u) : m₁ = m₂ → m₂ = m₃ → m₁ = m₃ := assume m₁ = m₂, assume m₂ = m₃, eq.transport.{u}[_, _, λ m, m₁ = m] ⟪m₂ = m₃⟫ ⟪m₁ = m₂⟫
lemma and.intro (φ ψ : Prop) : φ → ψ → φ ∧ ψ := assume φ, assume ψ, take (ξ : Prop), assume φ → ψ → ξ, ⟪φ → ψ → ξ⟫ ⟪φ⟫ ⟪ψ⟫

-- modus ponens
lemma mp (φ ψ : Prop) : φ → (φ → ψ) → ψ := assume φ, assume φ → ψ, ⟪φ → ψ⟫ ⟪φ⟫
lemma imp.trans (φ ψ ξ : Prop) : (φ → ψ) → (ψ → ξ) → φ → ξ := assume φ → ψ, assume ψ → ξ, assume φ, ⟪ψ → ξ⟫ (⟪φ → ψ⟫ ⟪φ⟫)
-- modus tollens
lemma mt (φ ψ : Prop) : (φ → ψ) → ¬ψ → ¬φ := imp.trans[_, _, _]
lemma contradiction (φ : Prop) : φ → ¬φ → ⊥ := mp[_, _]
lemma absurd (φ : Prop) : ⊥ → φ := assume ⊥, (change ∀ ξ, ξ, ⟪⊥⟫)[φ]

lemma eq.conv (φ ψ : Prop) : (φ = ψ) → φ → ψ := assume φ = ψ, (eq.transport.{Prop}[_, _, λ (ξ : Prop), ξ] ⟪φ = ψ⟫)
-- material adequacy
lemma ma (φ : Prop) : (⊤ = φ) → φ := assume ⊤ = φ, eq.conv[_, _] ⟪⊤ = φ⟫ top.intro

lemma not.fixed_point_free (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ,
have ¬φ := assume φ, contradiction[_] ⟪φ⟫ (eq.conv[_, _] ⟪φ = ¬φ⟫ ⟪φ⟫),
have φ := eq.conv[_, _] (eq.symm.{Prop}[_, _] ⟪φ = ¬φ⟫) ⟪¬φ⟫,
contradiction[_] ⟪φ⟫ ⟪¬φ⟫

/-
lemma not.fixed_point_free (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ,
have ¬φ := assume φ, contradiction ⟪φ⟫ (⟪φ = ¬φ⟫.conv ⟪φ⟫),
have φ := ⟪φ = ¬φ⟫.symm.conv ⟪¬φ⟫,
contradiction ⟪φ⟫ ⟪¬φ⟫

lemma not.no_fixpoint (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ, show ⊥, {
  let φ, ¬φ := ⟪⊥⟫.contradiction φ,
  let (¬φ) = φ, ¬φ := ⟪φ⟫.apply eq.conv[¬φ, φ],    -- yields ¬φ, which is automatically contracted with the one that comes from the contradiction tactic.
  ⟪(¬φ) = φ⟫.symmetry := ⟪φ = ¬φ⟫,
  ⟪¬φ⟫ := assume φ, show ⊥, {
     let φ, ¬φ := ⟪⊥⟫.contradiction φ,
     let φ := ⟪¬φ⟫.apply (eq.conv[φ, ¬φ] ⟪φ = ¬φ⟫),   -- φ is automatically contracted.
     ⟪φ⟫ := ⟪φ⟫
  }
}
-/

lemma exists.intro.{u} (P : u → Prop) (m : u) : P m → exists P :=
assume P m,
take (ξ : Prop),
assume ∀ x, P x → ξ,
⟪∀ x, P x → ξ⟫[m] ⟪P m⟫

lemma exists.elim.{u} (P : u → Prop) (φ : Prop) : exists P → (∀ x, P x → φ) → φ :=
assume exists P,
(change ∀ ξ, (∀ x, P x → ξ) → ξ, ⟪exists P⟫)[φ]

lemma and.elim (φ ψ ξ : Prop) : φ ∧ ψ → (φ → ψ → ξ) → ξ :=
assume φ ∧ ψ,
(change ∀ ξ, (φ → ψ → ξ) → ξ, ⟪φ ∧ ψ⟫)[ξ]

lemma and.left (φ ψ : Prop) : φ ∧ ψ → φ :=
assume φ ∧ ψ,
(and.elim[_, _, _] ⟪φ ∧ ψ⟫) (assume φ, assume ψ, ⟪φ⟫)

lemma and.right (φ ψ : Prop) : φ ∧ ψ → ψ :=
assume φ ∧ ψ,
(and.elim[_, _, _] ⟪φ ∧ ψ⟫) (assume φ, assume ψ, ⟪ψ⟫)

lemma or.left (φ ψ : Prop) : φ → φ ∨ ψ :=
assume φ,
take (ξ : Prop),
assume φ → ξ,
assume ψ → ξ,
⟪φ → ξ⟫ ⟪φ⟫

lemma or.right (φ ψ : Prop) : ψ → φ ∨ ψ :=
assume ψ,
take (ξ : Prop),
assume φ → ξ,
assume ψ → ξ,
⟪ψ → ξ⟫ ⟪ψ⟫

lemma or.elim (φ ψ ξ : Prop) : φ ∨ ψ → (φ → ξ) → (ψ → ξ) → ξ :=
assume φ ∨ ψ,
(change ∀ ξ, (φ → ξ) → (ψ → ξ) → ξ, ⟪φ ∨ ψ⟫)[ξ]

lemma not.intro (φ : Prop) : (φ → ⊥) → ¬φ :=
assume φ → ⊥,
⟪φ → ⊥⟫

lemma not.elim (φ : Prop) : ¬φ → φ → ⊥ :=
assume ¬φ,
⟪¬φ⟫

lemma top_ne_bot : ⊤ ≠ ⊥ :=
assume ⊤ = ⊥,
eq.conv[_, _] ⟪⊤ = ⊥⟫ top.intro

lemma eq.ap.{u, v} (m₁ m₂ : u) (f : u → v) : m₁ = m₂ → f m₁ = f m₂ :=
assume m₁ = m₂,
eq.transport.{u}[_, _, λ x, f m₁ = f x] ⟪m₁ = m₂⟫ (eq.refl.{v}[f m₁])

lemma eq.congr_fun.{u, v} (f₁ f₂ : u → v) (x : u) : f₁ = f₂ → f₁ x = f₂ x :=
assume f₁ = f₂,
eq.transport.{u → v}[_, _, (λ (f : u → v), f₁ x = f x)] ⟪f₁ = f₂⟫ eq.refl.{v}[f₁ x]

lemma eq.congr_arg.{u, v} (f : u → v) (x₁ x₂ : u) : x₁ = x₂ → f x₁ = f x₂ :=
assume x₁ = x₂,
eq.transport.{u}[_, _, (λ x, f x₁ = f x)] ⟪x₁ = x₂⟫ eq.refl.{v}[f x₁]

-- subsingleton
def unique.{u} (P : u → Prop) : Prop := ∀ (x₁ x₂ : u), P x₁ → P x₂ → x₁ = x₂

lemma uexists.intro.{u} (P : u → Prop) : exists P → unique P → uexists P :=
assume exists P,
assume unique P,
obtain (x : u), P x := ⟪exists P⟫,
exists.intro.{u}[(λ x, P x ∧ ∀ y, P y → x = y), x] (and.intro[_, _] ⟪P x⟫ (take (y : u), assume P y, (change ∀ x₁ x₂, P x₁ → P x₂ → x₁ = x₂, ⟪unique P⟫)[x, y] ⟪P x⟫ ⟪P y⟫))

lemma uexists.exists.{u} (P : u → Prop) : uexists P → exists P :=
assume uexists P,
obtain (x : u), P x ∧ ∀ (y : u), P y → x = y := ⟪uexists P⟫,
exists.intro.{u}[P, x] (and.left[_, _] ⟪P x ∧ ∀ y, P y → x = y⟫)

lemma uexists.unique.{u} (P : u → Prop) : uexists P → unique P :=
assume uexists P,
take (x₁ : u),
take (x₂ : u),
assume P x₁,
assume P x₂,
obtain (x : u), P x ∧ ∀ y, P y → x = y := ⟪uexists P⟫,
have ∀ y, P y → x = y := and.right[_, _] ⟪P x ∧ ∀ y, P y → x = y⟫,
have x = x₁ := ⟪∀ y, P y → x = y⟫[x₁] ⟪P x₁⟫,
have x = x₂ := ⟪∀ y, P y → x = y⟫[x₂] ⟪P x₂⟫,
eq.trans.{u}[_, _, _] (eq.symm.{u}[_, _] ⟪x = x₁⟫) ⟪x = x₂⟫

lemma iff.intro (φ ψ : Prop) : (φ → ψ) → (ψ → φ) → (φ ↔ ψ) :=
assume φ → ψ,
assume ψ → φ,
and.intro[_, _] ⟪φ → ψ⟫ ⟪ψ → φ⟫

lemma iff.right (φ ψ : Prop) : (φ ↔ ψ) → φ → ψ :=
assume φ ↔ ψ,
and.left[_, _] ⟪φ ↔ ψ⟫

lemma iff.left (φ ψ : Prop) : (φ ↔ ψ) → ψ → φ :=
assume φ ↔ ψ,
and.right[_, _] ⟪φ ↔ ψ⟫

lemma iff.trans (φ ψ ξ : Prop) : (φ ↔ ψ) → (ψ ↔ ξ) → (φ ↔ ξ) :=
assume φ ↔ ψ,
assume ψ ↔ ξ,
iff.intro[_, _]
  (imp.trans[_, _, _] (iff.right[_, _] ⟪φ ↔ ψ⟫) (iff.right[_, _] ⟪ψ ↔ ξ⟫))
  (imp.trans[_, _, _] (iff.left[_, _] ⟪ψ ↔ ξ⟫) (iff.left[_, _] ⟪φ ↔ ψ⟫))

lemma exists.map.{u} (P Q : u → Prop) : (∀ x, P x → Q x) → (∃ x, P x) → ∃ x, Q x :=
assume ∀ x, P x → Q x,
assume ∃ x, P x,
obtain (t : u), P t := ⟪∃ x, P x⟫,
exists.intro.{u}[Q, t] (⟪∀ x, P x → Q x⟫[t] ⟪P t⟫)

lemma unique.map.{u} (P Q : u → Prop) : (∀ x, P x → Q x) → unique.{u} Q → unique.{u} P :=
assume ∀ x, P x → Q x,
assume unique.{u} Q,
take (x₁ : u),
take (x₂ : u),
assume P x₁,
assume P x₂,
(change ∀ x₁ x₂, Q x₁ → Q x₂ → x₁ = x₂, ⟪unique.{u} Q⟫)[x₁, x₂] (⟪∀ x, P x → Q x⟫[x₁] ⟪P x₁⟫) (⟪∀ x, P x → Q x⟫[x₂] ⟪P x₂⟫)

lemma uexists.congr.{u} (P Q : u → Prop) : (∀ x, P x ↔ Q x) → ((∃! x, P x) ↔ ∃! x, Q x) :=
assume ∀ x, P x ↔ Q x,
have ∀ x, P x → Q x := take (x : u), iff.right[_, _] ⟪∀ x, P x ↔ Q x⟫[x],
have ∀ x, Q x → P x := take (x : u), iff.left[_, _] ⟪∀ x, P x ↔ Q x⟫[x],
iff.intro[(∃! x, P x), (∃! y, Q y)]
  (assume ∃! x, P x,
    uexists.intro.{u}[Q]
      (exists.map.{u}[P, Q] ⟪∀ x, P x → Q x⟫ (uexists.exists.{u}[P] ⟪∃! x, P x⟫))
      (unique.map.{u}[Q, P] ⟪∀ x, Q x → P x⟫ (uexists.unique.{u}[P] ⟪∃! x, P x⟫)))
  (assume ∃! x, Q x,
    uexists.intro.{u}[P]
      (exists.map.{u}[Q, P] ⟪∀ x, Q x → P x⟫ (uexists.exists.{u}[Q] ⟪∃! x, Q x⟫))
      (unique.map.{u}[P, Q] ⟪∀ x, P x → Q x⟫ (uexists.unique.{u}[Q] ⟪∃! x, Q x⟫)))

/-
 - Extensionality
 -/

lemma eq.congr_abs.{u, v} (m₁ m₂ : u) : (∀ (x : v), m₁ = m₂) → (λ (x : v), m₁) = (λ (x : v), m₂) :=
assume ∀ (x : v), m₁ = m₂,
fun_ext.{v, u}[(λ (x : v), m₁), (λ (x : v), m₂)] ⟪∀ (x : v), m₁ = m₂⟫

lemma eta_expand.{u, v} (f : u → v) : f = λ (x : u), f x :=
fun_ext.{u, v}[f, λ x, f x] (take (x : u), eq.refl.{v}[f x])

/-
 - functions
 -/

def injective.{u, v} (f : u → v) : Prop := ∀ x y, f x = f y → x = y
def surjective.{u, v} (f : u → v) : Prop := ∀ y, ∃ x, y = f x

lemma lawvere_fixpoint.{u, v} : (∃ (e : u → u → v), surjective e) → ∀ (f : v → v), ∃ y, y = f y :=
assume ∃ (e : u → u → v), surjective e,
take (f : v → v),
obtain (e : u → u → v), surjective e := ⟪∃ (e : u → u → v), surjective e⟫,
obtain (x : u), (λ x, f (e x x)) = e x := (change ∀ g, ∃ x, g = e x, ⟪surjective e⟫)[λ x, f (e x x)],
have f (e x x) = e x x := eq.congr_fun.{u, v}[_, _, x] ⟪(λ x, f (e x x)) = e x⟫,
exists.intro.{v}[(λ y, y = f y), e x x] (eq.symm.{v}[_, _] ⟪f (e x x) = e x x⟫)

lemma injective.unique.{u, v} (f : u → v) : injective f → ∀ y, unique (λ x, y = f x) :=
assume injective f,
take (y : v),
take (x₁ : u),
take (x₂ : u),
assume y = f x₁,
assume y = f x₂,
(change ∀ x y, f x = f y → x = y, ⟪injective f⟫)[x₁, x₂] (eq.trans.{v}[_, _, _] (eq.symm.{v}[_, _] ⟪y = f x₁⟫) ⟪y = f x₂⟫)

/-
 - sets
 -/

infix ∈ : 50 := in
infix ∉ : 50 := notin
infix ⊆ : 50 := subset
infixl ∩ : 70 := cap
infixl ∪ : 65 := cup
infix ∖ : 70 := setminus
nofix ∅ := empty

-- type set u := u → Prop

def in.{u} (x : u) (s : set u) : Prop := s x
def notin.{u} (x : u) (s : set u) : Prop := ¬(x ∈ s)
def univ.{u} : set u := λ x, ⊤
def empty.{u} : set u := λ x, ⊥
def subset.{u} (s : set u) (t : set u) : Prop := ∀ x, x ∈ s → x ∈ t
def sep.{u} (s : set u) (φ : set u) : set u := λ x, x ∈ s ∧ φ x
def cap.{u} (s : set u) (t : set u) : set u := { x | x ∈ s ∧ x ∈ t }
def cup.{u} (s : set u) (t : set u) : set u := { x | x ∈ s ∨ x ∈ t }
def bigcap.{u} (a : set (set u)) : set u := { x | ∀ s, s ∈ a → x ∈ s }
def bigcup.{u} (a : set (set u)) : set u := { x | ∃ s, s ∈ a ∧ x ∈ s }
def power.{u} (s : set u) : set (set u) := { t | t ⊆ s }
def setminus.{u} (s : set u) (t : set u) : set u := { x | x ∈ s ∧ x ∉ t }
def im.{u, v} (f : u → v) (s : set u) : set v := { y | ∃ x, x ∈ s ∧ y = f x }

lemma cantor.{u} : ¬(∃ (e : u → set u), surjective e) :=
mt[_, _] lawvere_fixpoint.{u, Prop} (
    assume ∀ (f : Prop → Prop), ∃ y, y = f y,
    obtain (y : Prop), y = ¬y := ⟪∀ (f : Prop → Prop), ∃ y, y = f y⟫[not],
    contradiction[_] ⟪y = ¬y⟫ (not.fixed_point_free[y]))

/-
 - comprehension types
 -/

-- e.g. type def bool := { x : Prop | x = ⊤ ∨ x = ⊥ } yields comprehension.{Prop, bool}
type const comprehension : Type → Type → Type
const char.{v, u} : comprehension v u → v → Prop
const rep.{v, u} : comprehension v u → u → v
axiom rep.spec.{v, u} (d : comprehension v u) : injective (rep d) ∧ (∀ y, char d y ↔ ∃! x, y = rep d x)

lemma rep.injective.{v, u} (d : comprehension v u) : injective (rep d) :=
and.left[_, _] rep.spec.{v, u}[d]

lemma rep.unique.{v, u} (d : comprehension v u) (y : v) : unique (λ x, y = rep d x) :=
(injective.unique.{u, v}[rep d] rep.injective.{v, u}[d])[y]

lemma rep.iff_char.{v, u} (d : comprehension v u) (y : v) : char d y ↔ ∃! x, y = rep d x :=
(and.right[_, _] rep.spec.{v, u}[d])[y]

lemma rep.char.{v, u} (d : comprehension v u) (y : v) : (∃! x, y = rep d x) → char d y :=
iff.left[_, _] rep.iff_char.{v, u}[d, y]

lemma char.abs.{v, u} (d : comprehension v u) (y : v) : char d y → ∃! x, y = rep d x :=
iff.right[_, _] rep.iff_char.{v, u}[d, y]

lemma char.rep.{v, u} (d : comprehension v u) (x : u) : char d (rep d x) :=
rep.char.{v, u}[d, rep d x] (uexists.intro.{u}[λ z, rep d x = rep d z] (exists.intro.{u}[(λ z, rep d x = rep d z), x] eq.refl.{v}[rep d x]) rep.unique.{v, u}[d, rep d x])

lemma comprehension.ind.{v, u} (d : comprehension v u) (P : u → Prop) : (∀ (y : v) (x : u), y = rep d x → P x) → ∀ x, P x :=
assume ∀ (y : v) (x : u), y = rep d x → P x,
take (x : u),
⟪∀ (y : v) (x : u), y = rep d x → P x⟫[rep d x, x] eq.refl.{v}[rep d x]

/-
 - bool
 -/

-- The type of decidable propositions.
-- type def bool := { φ : Prop | φ = ⊤ ∨ φ = ⊥ }
type const bool : Type
const bool.comprehension : comprehension Prop bool
def bool.char : Prop → Prop := λ φ, φ = ⊤ ∨ φ = ⊥
axiom bool.spec : bool.char = char bool.comprehension
lemma bool.char.unfold (φ : Prop) : bool.char φ → char bool.comprehension φ := assume bool.char φ, eq.conv[_, _] (eq.congr_fun.{Prop, Prop}[_, _, φ] bool.spec) ⟪bool.char φ⟫
lemma bool.char.fold (φ : Prop) : char bool.comprehension φ → bool.char φ := assume char bool.comprehension φ, eq.conv[_, _] (eq.congr_fun.{Prop, Prop}[_, _, φ] (eq.symm.{Prop → Prop}[_, _] bool.spec)) ⟪char bool.comprehension φ⟫
def bool.rep : bool → Prop := rep bool.comprehension
lemma bool.char.abs (φ : Prop) : bool.char φ → ∃! x, φ = bool.rep x := assume bool.char φ, char.abs.{Prop, bool}[_, φ] (bool.char.unfold[φ] ⟪bool.char φ⟫)
lemma bool.rep.char (φ : Prop) : (∃! x, φ = bool.rep x) → bool.char φ := assume ∃! x, φ = bool.rep x, bool.char.fold[φ] (rep.char.{Prop, bool}[_, φ] ⟪∃! x, φ = bool.rep x⟫)
lemma bool.char.rep (x : bool) : bool.char (bool.rep x) := bool.char.fold[bool.rep x] char.rep.{Prop, bool}[_, x]
lemma bool.comprehension.ind (P : bool → Prop) : (∀ (φ : Prop) (x : bool), φ = bool.rep x → P x) → ∀ x, P x := comprehension.ind.{Prop, bool}[_, P]
lemma bool.rep.injective : injective bool.rep := rep.injective.{Prop, bool}[_]

lemma bool.tt_uexists : ∃! (tt : bool), ⊤ = bool.rep tt :=
bool.char.abs[⊤] (or.left[_, ⊤ = ⊥] eq.refl.{Prop}[⊤])

lemma bool.ff_uexists : ∃! (ff : bool), ⊥ = bool.rep ff :=
bool.char.abs[⊥] (or.right[⊥ = ⊤, _] eq.refl.{Prop}[⊥])

-- def (tt : bool), ⊤ = bool.rep tt := bool.tt.uexists
-- def (ff : bool), ⊥ = bool.rep ff := bool.ff.uexists
const tt : bool
axiom tt.spec : ⊤ = bool.rep tt
const ff : bool
axiom ff.spec : ⊥ = bool.rep ff

lemma bool.ind (P : bool → Prop) : P tt → P ff → ∀ b, P b :=
assume P tt,
assume P ff,
bool.comprehension.ind[P] (
  take (φ : Prop),
  take (b : bool),
  assume φ = bool.rep b,
  have φ = ⊤ ∨ φ = ⊥ := eq.transport.{Prop}[_, _, bool.char] (eq.symm.{Prop}[_, _] ⟪φ = bool.rep b⟫) bool.char.rep[b],
  or.elim[_, _, _] ⟪φ = ⊤ ∨ φ = ⊥⟫
    (assume φ = ⊤,
      have bool.rep tt = bool.rep b := eq.trans.{Prop}[_, _, _] (eq.symm.{Prop}[_, _] tt.spec) (eq.trans.{Prop}[_, _, _] (eq.symm.{Prop}[_, _] ⟪φ = ⊤⟫) ⟪φ = bool.rep b⟫),
      have tt = b := (change ∀ x y, bool.rep x = bool.rep y → x = y, bool.rep.injective)[tt, b] ⟪bool.rep tt = bool.rep b⟫,
      eq.transport.{bool}[_, _, P] ⟪tt = b⟫ ⟪P tt⟫)
    (assume φ = ⊥,
      have bool.rep ff = bool.rep b := eq.trans.{Prop}[_, _, _] (eq.symm.{Prop}[_, _] ff.spec) (eq.trans.{Prop}[_, _, _] (eq.symm.{Prop}[_, _] ⟪φ = ⊥⟫) ⟪φ = bool.rep b⟫),
      have ff = b := (change ∀ x y, bool.rep x = bool.rep y → x = y, bool.rep.injective)[ff, b] ⟪bool.rep ff = bool.rep b⟫,
      eq.transport.{bool}[_, _, P] ⟪ff = b⟫ ⟪P ff⟫))

lemma bool.case : ∀ b, b = tt ∨ b = ff :=
bool.ind[λ b, b = tt ∨ b = ff] (or.left[_, tt = ff] eq.refl.{bool}[tt]) (or.right[ff = tt, _] eq.refl.{bool}[ff])

lemma bool.tt_ne_ff : tt ≠ ff :=
assume tt = ff,
(change (⊤ = ⊥) → ⊥, top_ne_bot) (eq.trans.{Prop}[_, _, _] tt.spec (eq.trans.{Prop}[_, _, _] (eq.congr_arg.{bool, Prop}[bool.rep, _, _] ⟪tt = ff⟫) (eq.symm.{Prop}[_, _] ff.spec)))

lemma bool.rec_exists.{u} (on_tt : u) (on_ff : u) (b : bool) : ∃ (rec : u), (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff) :=
or.elim[_, _, _] bool.case[b]
  (assume b = tt,
    exists.intro.{u}[(λ rec, (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff)), on_tt]
      (and.intro[_, _]
        (assume b = tt, eq.refl.{u}[on_tt])
        (assume b = ff, absurd[on_tt = on_ff] ((change tt = ff → ⊥, bool.tt_ne_ff) (eq.trans.{bool}[_, _, _] (eq.symm.{bool}[_, _] ⟪b = tt⟫) ⟪b = ff⟫)))))
  (assume b = ff,
    exists.intro.{u}[(λ rec, (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff)), on_ff]
      (and.intro[_, _]
        (assume b = tt, absurd[on_ff = on_tt] ((change tt = ff → ⊥, bool.tt_ne_ff) (eq.trans.{bool}[_, _, _] (eq.symm.{bool}[_, _] ⟪b = tt⟫) ⟪b = ff⟫)))
        (assume b = ff, eq.refl.{u}[on_ff])))

lemma bool.rec_unique.{u} (on_tt : u) (on_ff : u) (b : bool) : unique λ (rec : u), (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff) :=
take (r₁ : u),
take (r₂ : u),
assume (b = tt → r₁ = on_tt) ∧ (b = ff → r₁ = on_ff),
assume (b = tt → r₂ = on_tt) ∧ (b = ff → r₂ = on_ff),
or.elim[_, _, _] bool.case[b]
  (assume b = tt,
    have r₁ = on_tt := and.left[_, _] ⟪(b = tt → r₁ = on_tt) ∧ (b = ff → r₁ = on_ff)⟫ ⟪b = tt⟫,
    have r₂ = on_tt := and.left[_, _] ⟪(b = tt → r₂ = on_tt) ∧ (b = ff → r₂ = on_ff)⟫ ⟪b = tt⟫,
    eq.trans.{u}[_, _, _] ⟪r₁ = on_tt⟫ (eq.symm.{u}[_, _] ⟪r₂ = on_tt⟫))
  (assume b = ff,
    have r₁ = on_ff := and.right[_, _] ⟪(b = tt → r₁ = on_tt) ∧ (b = ff → r₁ = on_ff)⟫ ⟪b = ff⟫,
    have r₂ = on_ff := and.right[_, _] ⟪(b = tt → r₂ = on_tt) ∧ (b = ff → r₂ = on_ff)⟫ ⟪b = ff⟫,
    eq.trans.{u}[_, _, _] ⟪r₁ = on_ff⟫ (eq.symm.{u}[_, _] ⟪r₂ = on_ff⟫))

lemma bool.rec_uexists.{u} (on_tt : u) (on_ff : u) (b : bool) : ∃! (rec : u), (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff) :=
uexists.intro.{u}[λ (rec : u), (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff)] bool.rec_exists.{u}[on_tt, on_ff, b] bool.rec_unique.{u}[on_tt, on_ff, b]

-- def (rec.{u} (on_tt : u) (on_ff : u) (b : bool) : u), (b = tt → rec on_tt on_ff b = on_tt) ∧ (b = ff → rec on_tt on_ff b = on_ff) := bool.rec_uexists.{u}
const bool.rec.{u} : u → u → bool → u
axiom bool.rec.spec.{u} (on_tt : u) (on_ff : u) (b : bool) : (b = tt → bool.rec.{u} on_tt on_ff b = on_tt) ∧ (b = ff → bool.rec.{u} on_tt on_ff b = on_ff)

def bool.cond.{u} (b : bool) (then : u) (else : u) : u := bool.rec.{u} then else b

/-
 - unit
 -/

-- type def unit := { φ : Prop | ⊤ = φ }
-- We do not use { φ | φ } in the definition because prop_ext is necessary for unit to have only one element.
type const unit : Type
const unit.comprehension : comprehension Prop unit
def unit.char : Prop → Prop := λ φ, ⊤ = φ
axiom unit.spec : unit.char = char unit.comprehension
lemma unit.char.unfold (φ : Prop) : unit.char φ → char unit.comprehension φ := assume unit.char φ, eq.conv[_, _] (eq.congr_fun.{Prop, Prop}[_, _, φ] unit.spec) ⟪unit.char φ⟫
lemma unit.char.fold (φ : Prop) : char unit.comprehension φ → unit.char φ := assume char unit.comprehension φ, eq.conv[_, _] (eq.congr_fun.{Prop, Prop}[_, _, φ] (eq.symm.{Prop → Prop}[_, _] unit.spec)) ⟪char unit.comprehension φ⟫
def unit.rep : unit → Prop := rep unit.comprehension
lemma unit.char.abs (φ : Prop) : unit.char φ → ∃! x, φ = unit.rep x := assume unit.char φ, char.abs.{Prop, unit}[_, φ] (unit.char.unfold[φ] ⟪unit.char φ⟫)
lemma unit.rep.char (φ : Prop) : (∃! x, φ = unit.rep x) → unit.char φ := assume ∃! x, φ = unit.rep x, unit.char.fold[φ] (rep.char.{Prop, unit}[_, φ] ⟪∃! x, φ = unit.rep x⟫)
lemma unit.char.rep (x : unit) : unit.char (unit.rep x) := unit.char.fold[unit.rep x] char.rep.{Prop, unit}[_, x]
lemma unit.comprehension.ind (P : unit → Prop) : (∀ (φ : Prop) (x : unit), φ = unit.rep x → P x) → ∀ x, P x := comprehension.ind.{Prop, unit}[_, P]
lemma unit.rep.injective : injective unit.rep := rep.injective.{Prop, unit}[_]

lemma unit.star_uexists : ∃! (star : unit), ⊤ = unit.rep star :=
unit.char.abs[⊤] eq.refl.{Prop}[⊤]

-- def (star : unit), ⊤ = unit.rep star := unit.star_uexists
const star : unit
axiom star.spec : ⊤ = unit.rep star

lemma unit.unique (x y : unit) : x = y :=
have unit.rep x = unit.rep y := eq.trans.{Prop}[_, _, _] (eq.symm.{Prop}[_, _] unit.char.rep[x]) unit.char.rep[y],
(change ∀ x y, unit.rep x = unit.rep y → x = y, unit.rep.injective)[x, y] ⟪unit.rep x = unit.rep y⟫

lemma unit.eta_expand (x : unit) : x = star :=
unit.unique[x, star]

lemma unit.eta_reduce (x : unit) : star = x :=
unit.unique[star, x]

lemma unit.ind (P : unit → Prop) : P star → ∀ (x : unit), P x :=
assume P star,
take (x : unit),
eq.transport.{unit}[_, _, P] unit.eta_reduce[x] ⟪P star⟫

/-
 - pair
 -/

-- type def pair u v := { e : u → v → Prop | ∃ a b, e a b ∧ ∀ a₁ b₁, e a₁ b₁ → a = a₁ ∧ b = b₁ }
type const pair : Type → Type → Type
const pair.comprehension.{u, v} : comprehension (u → v → Prop) (pair u v)
def pair.char.{u, v} (e : u → v → Prop) : Prop := ∃ a b, e a b ∧ ∀ a₁ b₁, e a₁ b₁ → a = a₁ ∧ b = b₁
axiom pair.spec.{u, v} : pair.char.{u, v} = char pair.comprehension.{u, v}

lemma pair.char.unfold.{u, v} (e : u → v → Prop) : pair.char e → char pair.comprehension e :=
  assume pair.char e,
    eq.conv[_, _] (eq.congr_fun.{u → v → Prop, Prop}[_, _, e] pair.spec.{u, v}) ⟪pair.char e⟫

lemma pair.char.fold.{u, v} (e : u → v → Prop) : char pair.comprehension e → pair.char e :=
  assume char pair.comprehension e,
    eq.conv[_, _] (eq.congr_fun.{u → v → Prop, Prop}[_, _, e] (eq.symm.{(u → v → Prop) → Prop}[_, _] pair.spec.{u, v})) ⟪char pair.comprehension e⟫

def pair.rep.{u, v} : pair u v → u → v → Prop := rep pair.comprehension.{u, v}

lemma pair.char.abs.{u, v} (e : u → v → Prop) : pair.char e → ∃! p, e = pair.rep p :=
  assume pair.char e,
    char.abs.{u → v → Prop, pair u v}[_, e] (pair.char.unfold.{u, v}[e] ⟪pair.char e⟫)

lemma pair.rep.char.{u, v} (e : u → v → Prop) : (∃! p, e = pair.rep p) → pair.char e :=
  assume ∃! p, e = pair.rep p,
    pair.char.fold.{u, v}[e] (rep.char.{u → v → Prop, pair u v}[_, e] ⟪∃! p, e = pair.rep p⟫)

lemma pair.char.rep.{u, v} (p : pair u v) : pair.char (pair.rep p) :=
  pair.char.fold.{u, v}[pair.rep p] char.rep.{u → v → Prop, pair u v}[_, p]

lemma pair.rep.injective.{u, v} : injective pair.rep.{u, v} :=
  rep.injective.{u → v → Prop, pair u v}[_]

/- a bug of the unifier.
lemma fst_uexists.{u, v} (p : pair u v) : ∃! a, ∃! b, pair.rep p a b :=
  obtain (a : u), ∃ b, pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ := pair.char.rep.{u, v}[p],
  obtain (b : v), pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ := ⟪∃ b, pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
  have pair.rep p a b :=
    and.left[_, _] ⟪pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
  have ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ :=
    and.right[_, _] ⟪pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
  uexists.intro.{u}[_]
    (exists.intro.{u}[_, _]
      (uexists.intro.{v}[_]
        (exists.intro.{v}[_, _] ⟪pair.rep p a b⟫)
        (take (b₁ : v),
         take (b₂ : v),
         assume pair.rep p a b₁,
         assume pair.rep p a b₂,
         have b = b₁ := and.right[_, _] (⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[a, b₁] ⟪pair.rep p a b₁⟫),
         have b = b₂ := and.right[_, _] (⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[a, b₂] ⟪pair.rep p a b₂⟫),
         eq.trans.{v}[_, _, _] (eq.symm.{v}[_, _] ⟪b = b₁⟫) ⟪b = b₂⟫)))
    (take (a₁ : u),
     take (a₂ : u),
     assume ∃ b, pair.rep p a₁ b,
     assume ∃ b, pair.rep p a₂ b,
     obtain (b₁ : v), pair.rep p a₁ b₁ := ⟪∃ b, pair.rep p a₁ b⟫,
     obtain (b₂ : v), pair.rep p a₂ b₂ := ⟪∃ b, pair.rep p a₂ b⟫,
     have a = a₁ := and.left[_, _] (⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[a₁, b₁] ⟪pair.rep p a₁ b₁⟫),
     have a = a₂ := and.left[_, _] (⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[a₂, b₂] ⟪pair.rep p a₂ b₂⟫),
     eq.trans.{u}[_, _, _] (eq.symm.{u}[_, _] ⟪a = a₁⟫) ⟪a = a₂⟫)
-/

lemma fst_uexists.{u, v} (p : pair u v) : ∃! a, ∃! b, pair.rep p a b :=
  obtain (a : u), ∃ b, pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ := pair.char.rep.{u, v}[p],
  obtain (b : v), pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ := ⟪∃ b, pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
  have pair.rep p a b :=
    and.left[_, _] ⟪pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
  have ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ :=
    and.right[_, _] ⟪pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
  uexists.intro.{u}[_]
    (exists.intro.{u}[_, _]
      (uexists.intro.{v}[_]
        (exists.intro.{v}[_, _] ⟪pair.rep p a b⟫)
        (take (b₁ : v),
         take (b₂ : v),
         assume pair.rep p a b₁,
         assume pair.rep p a b₂,
         have b = b₁ := and.right[_, _] (⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[a, b₁] ⟪pair.rep p a b₁⟫),
         have b = b₂ := and.right[_, _] (⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[a, b₂] ⟪pair.rep p a b₂⟫),
         eq.trans.{v}[_, _, _] (eq.symm.{v}[_, _] ⟪b = b₁⟫) ⟪b = b₂⟫)))
    (take (a₁ : u),
     take (a₂ : u),
     assume ∃! b, pair.rep p a₁ b,
     assume ∃! b, pair.rep p a₂ b,
     obtain (b₁ : v), pair.rep p a₁ b₁ := uexists.exists.{v}[_] ⟪∃! b, pair.rep p a₁ b⟫,
     obtain (b₂ : v), pair.rep p a₂ b₂ := uexists.exists.{v}[_] ⟪∃! b, pair.rep p a₂ b⟫,
     have a = a₁ := and.left[_, _] (⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[a₁, b₁] ⟪pair.rep p a₁ b₁⟫),
     have a = a₂ := and.left[_, _] (⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[a₂, b₂] ⟪pair.rep p a₂ b₂⟫),
     eq.trans.{u}[_, _, _] (eq.symm.{u}[_, _] ⟪a = a₁⟫) ⟪a = a₂⟫)

-- def (fst.{u, v} (p : pair u v) : u), ∃! b, pair.rep p (fst p) b := fst_uexists.{u, v}[p]
const fst.{u, v} : pair u v → u
axiom fst.spec.{u, v} (p : pair u v) : ∃! b, pair.rep p (fst p) b

-- def (snd.{u, v} (p : pair u v) : v), pair.rep p (fst p) (snd p) := fst.spec.{u, v}[p]
const snd.{u, v} : pair u v → v
axiom snd.spec.{u, v} (p : pair u v) : pair.rep p (fst p) (snd p)

lemma pair.proj.spec.{u, v} (p : pair u v) : pair.rep p (fst p) (snd p) := snd.spec.{u, v}[p]

def pair.mk_rep.{u, v} (x : u) (y : v) : u → v → Prop := λ a b, x = a ∧ y = b

lemma pair.mk_rep.char.{u, v} (x : u) (y : v) : pair.char (pair.mk_rep x y) :=
  exists.intro.{u}[_, _]
  (exists.intro.{v}[_, _]
    (and.intro[_, _]
      (and.intro[_, _] eq.refl.{u}[x] eq.refl.{v}[y])
      (take (x₁ : u),
      take (y₁ : v),
      assume pair.mk_rep x y x₁ y₁,
      ⟪pair.mk_rep x y x₁ y₁⟫)))

lemma pair.mk_uexists.{u, v} (x : u) (y : v) : ∃! p, pair.mk_rep x y = pair.rep p :=
  pair.char.abs.{u, v}[pair.mk_rep x y] (pair.mk_rep.char.{u, v}[x, y])

-- def (pair.mk.{u, v} (x : u) (y : v) : pair u v), pair.mk_rep x y = pair.rep (pair.mk x y) := pair.mk_uexists.{u, v}[x, y]
const pair.mk.{u, v} : u → v → pair u v
axiom pair.mk.spec.{u, v} (x : u) (y : v) : pair.mk_rep x y = pair.rep (pair.mk x y)

lemma pair.beta.{u, v} (x : u) (y : v) : x = fst (pair.mk x y) ∧ y = snd (pair.mk x y) :=
  have pair.rep (pair.mk x y) (fst (pair.mk x y)) (snd (pair.mk x y)) := pair.proj.spec.{u, v}[pair.mk x y],
  eq.conv[_, _]
    (eq.congr_fun.{v, Prop}[_, _, snd (pair.mk x y)]
      (eq.congr_fun.{u, v → Prop}[_, _, fst (pair.mk x y)]
        (eq.symm.{u → v → Prop}[_, _]
          pair.mk.spec.{u, v}[x, y])))
    ⟪pair.rep (pair.mk x y) (fst (pair.mk x y)) (snd (pair.mk x y))⟫

lemma pair.proj.unique.{u, v} (p : pair u v) (x₁ x₂ : u) (y₁ y₂ : v) : pair.rep p x₁ y₁ → pair.rep p x₂ y₂ → x₁ = x₂ ∧ y₁ = y₂ :=
assume pair.rep p x₁ y₁,
assume pair.rep p x₂ y₂,
have ∃ a b, pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ := pair.char.rep.{u, v}[p],
obtain (a : u), ∃ b, pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ := ⟪∃ a b, pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
obtain (b : v), pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ := ⟪∃ b, pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
have ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁ := and.right[_, _] ⟪pair.rep p a b ∧ ∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫,
have a = x₁ ∧ b = y₁ := ⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[x₁, y₁] ⟪pair.rep p x₁ y₁⟫,
have a = x₂ ∧ b = y₂ := ⟪∀ a₁ b₁, pair.rep p a₁ b₁ → a = a₁ ∧ b = b₁⟫[x₂, y₂] ⟪pair.rep p x₂ y₂⟫,
and.intro[_, _]
  (eq.trans.{u}[_, _, _] (eq.symm.{u}[_, _] (and.left[_, _] ⟪a = x₁ ∧ b = y₁⟫)) (and.left[_, _] ⟪a = x₂ ∧ b = y₂⟫))
  (eq.trans.{v}[_, _, _] (eq.symm.{v}[_, _] (and.right[_, _] ⟪a = x₁ ∧ b = y₁⟫)) (and.right[_, _] ⟪a = x₂ ∧ b = y₂⟫))

lemma pair.eta.help₁.{u, v} (p : pair u v) (x : u) (y : v) : pair.rep p x y ↔ x = fst p ∧ y = snd p :=
iff.intro[_, _]
  (assume pair.rep p x y,
   pair.proj.unique.{u, v}[_, _, _, _, _] ⟪pair.rep p x y⟫ pair.proj.spec.{u, v}[p])
  (assume x = fst p ∧ y = snd p,
   have x = fst p := and.left[_, _] ⟪x = fst p ∧ y = snd p⟫,
   have y = snd p := and.right[_, _] ⟪x = fst p ∧ y = snd p⟫,
   eq.conv[_, _] (eq.trans.{Prop}[_, _, _] (eq.congr_fun.{v, Prop}[_, _, snd p] (eq.congr_arg.{u, v → Prop}[pair.rep p, _, _] (eq.symm.{u}[_, _] ⟪x = fst p⟫))) (eq.congr_arg.{v, Prop}[pair.rep p x, _, _] (eq.symm.{v}[_, _] ⟪y = snd p⟫))) pair.proj.spec.{u, v}[p])

lemma pair.eta.help₂.{u, v} (p : pair u v) (x : u) (y : v) : (x = fst p ∧ y = snd p) ↔ pair.rep (pair.mk (fst p) (snd p)) x y :=
have (fst p = x ∧ snd p = y) = pair.rep (pair.mk (fst p) (snd p)) x y :=
  eq.congr_fun.{v, Prop}[_, _, y] (eq.congr_fun.{u, v → Prop}[_, _, x] pair.mk.spec.{u, v}[fst p, snd p]),
iff.intro[_, _]
  (assume x = fst p ∧ y = snd p,
   have fst p = x := eq.symm.{u}[_, _] (and.left[_, _] ⟪x = fst p ∧ y = snd p⟫),
   have snd p = y := eq.symm.{v}[_, _] (and.right[_, _] ⟪x = fst p ∧ y = snd p⟫),
   eq.conv[_, _] ⟪(fst p = x ∧ snd p = y) = pair.rep (pair.mk (fst p) (snd p)) x y⟫ (and.intro[_, _] ⟪fst p = x⟫ ⟪snd p = y⟫))
  (assume pair.rep (pair.mk (fst p) (snd p)) x y,
   have fst p = x ∧ snd p = y := eq.conv[_, _] (eq.symm.{Prop}[_, _] ⟪(fst p = x ∧ snd p = y) = pair.rep (pair.mk (fst p) (snd p)) x y⟫) ⟪pair.rep (pair.mk (fst p) (snd p)) x y⟫,
   have x = fst p := eq.symm.{u}[_, _] (and.left[_, _] ⟪fst p = x ∧ snd p = y⟫),
   have y = snd p := eq.symm.{v}[_, _] (and.right[_, _] ⟪fst p = x ∧ snd p = y⟫),
   and.intro[_, _] ⟪x = fst p⟫ ⟪y = snd p⟫)

lemma pair.eta.{u, v} (p : pair u v) : p = pair.mk (fst p) (snd p) :=
pair.rep.injective.{u, v}[_, _]
  (fun_ext.{u, v → Prop}[_, _]
    (take (x : u),
      fun_ext.{v, Prop}[_, _]
        (take (y : v), prop_ext[_, _] (iff.trans[_, _, _] pair.eta.help₁.{u, v}[p, x, y] pair.eta.help₂.{u, v}[p, x, y]))))

/-
 - support
 -/

-- a.k.a. the bracket type, or the propositional truncation
-- type support u := { x : unit | ∃ (a : u), ⊤ }
type const support : Type → Type
const support.comprehension.{u} : comprehension unit (support u)
def support.char.{u} : unit → Prop := λ x, ∃ (a : u), ⊤
axiom support.spec.{u} : support.char.{u} = char support.comprehension.{u}
lemma support.char.unfold.{u} (x : unit) : support.char.{u} x → char support.comprehension.{u} x := assume support.char.{u} x, eq.conv[_, _] (eq.congr_fun.{unit, Prop}[_, _, x] support.spec.{u}) ⟪support.char.{u} x⟫
lemma support.char.fold.{u} (x : unit) : char support.comprehension.{u} x → support.char.{u} x := assume char support.comprehension.{u} x, eq.conv[_, _] (eq.congr_fun.{unit, Prop}[_, _, x] (eq.symm.{unit → Prop}[_, _] support.spec.{u})) ⟪char support.comprehension.{u} x⟫
def support.rep.{u} : support u → unit := rep support.comprehension.{u}
lemma support.char.abs.{u} (x : unit) : support.char.{u} x → ∃! h, x = support.rep.{u} h := assume support.char.{u} x, char.abs.{unit, support u}[_, x] (support.char.unfold.{u}[x] ⟪support.char.{u} x⟫)
lemma support.rep.char.{u} (x : unit) : (∃! h, x = support.rep.{u} h) → support.char.{u} x := assume ∃! h, x = support.rep.{u} h, support.char.fold.{u}[x] (rep.char.{unit, support u}[_, x] ⟪∃! h, x = support.rep.{u} h⟫)
lemma support.char.rep.{u} (h : support u) : support.char.{u} (support.rep.{u} h) := support.char.fold.{u}[support.rep.{u} h] char.rep.{unit, support u}[_, h]
lemma support.comprehension.ind.{u} (P : support u → Prop) : (∀ (x : unit) (h : support u), x = support.rep.{u} h → P h) → ∀ h, P h := comprehension.ind.{unit, support u}[_, P]
lemma support.rep.injective.{u} : injective support.rep.{u} := rep.injective.{unit, support u}[_]

lemma support.char.unfold_.{u} : support.char.{u} star → char support.comprehension.{u} star := assume support.char.{u} star, eq.conv[_, _] (eq.congr_fun.{unit, Prop}[_, _, star] support.spec.{u}) ⟪support.char.{u} star⟫
lemma support.char.fold_.{u} : char support.comprehension.{u} star → support.char.{u} star := assume char support.comprehension.{u} star, eq.conv[_, _] (eq.congr_fun.{unit, Prop}[_, _, star] (eq.symm.{unit → Prop}[_, _] support.spec.{u})) ⟪char support.comprehension.{u} star⟫
lemma support.char.help.{u} : (∃! (h : support u), ⊤) ↔ (∃! (h : support u), star = support.rep.{u} h) :=
(uexists.congr.{support u}[(λ (h : support u), ⊤), (λ h, star = support.rep.{u} h)]
  (take (h : support u),
    iff.intro[_, _]
      (assume ⊤,
        unit.eta_reduce[support.rep.{u} h])
      (assume star = support.rep.{u} h,
        top.intro)))
lemma support.char.abs_.{u} : support.char.{u} star → ∃! (h : support u), ⊤ := assume support.char.{u} star, iff.left[_, _] support.char.help.{u} (support.char.abs.{u}[star] ⟪support.char.{u} star⟫)
lemma support.rep.char_.{u} : (∃! (h : support u), ⊤) → support.char.{u} star :=
assume ∃! (h : support u), ⊤,
have ∃! (h : support u), star = support.rep.{u} h :=
  iff.right[_, _] support.char.help.{u} ⟪∃! (h : support u), ⊤⟫,
support.rep.char.{u}[star] ⟪∃! (h : support u), star = support.rep.{u} h⟫
lemma support.char.rep_.{u} (h : support u) : support.char.{u} star := support.char.rep.{u}[h]

lemma support.mk_uexists.{u} (x : u) : ∃! (mk : support u), ⊤ :=
have ∃ (x : u), ⊤ :=
  exists.intro.{u}[λ (x : u), ⊤, x] top.intro,
support.char.abs_.{u} ⟪∃ (x : u), ⊤⟫

-- def (support.mk.{u} (x : u) : support u), ⊤ := support.mk_uexists.{u}[x]
const support.mk.{u} : u → support u

lemma support.unique.{u} (h₁ h₂ : support u) : h₁ = h₂ :=
(change ∀ h₁ h₂, support.rep.{u} h₁ = support.rep.{u} h₂ → h₁ = h₂, support.rep.injective.{u})[h₁, h₂] unit.unique[support.rep.{u} h₁, support.rep.{u} h₂]

lemma support.exists_imp_uexists.{u} (P : support u → Prop) : (∃ h, P h) → ∃! h, P h :=
assume ∃ h, P h,
uexists.intro.{support u}[P]
  ⟪∃ h, P h⟫
  (take (h₁ : support u), take (h₂ : support u), assume P h₁, assume P h₂, support.unique.{u}[h₁, h₂])

lemma support.join_uexists.{u} (h : support (support u)) : ∃! (h : support u), ⊤ :=
support.exists_imp_uexists.{u}[λ (h : support u), ⊤] support.char.rep_.{support u}[h]

-- def (support.join.{u} (h : support (support u)) : support u), ⊤ := support.join_uexists.{u}[h]
const support.join.{u} : support (support u) → support u

-- internal global choice operator
-- 
-- Introducing this constant restricts the class of models to toposes whose supports split.
-- Note we do not have an object-level function assigning for each type u the choice function,
-- which would imply axiom of choice.
-- In (dependent) type theory, this operator corresponds via the propositions-as-types paradigm
-- to the law of double negation.
const epsilon.{u} : support u → u

/-
 - natural numbers
 -/

type const ℕ : Type
const zero : ℕ
const succ : ℕ → ℕ
axiom ind : ∀ n, ∀ P, P zero ∧ (∀ n, P n → P (succ n)) → P n
const rec.{u} : ℕ → u → (u → u) → u
axiom rec.spec.{u} : ∀ (d₁ : u) (d₂ : u → u), rec zero d₁ d₂ = d₁ ∧ (∀ n, rec (succ n) d₁ d₂ = d₂ (rec n d₁ d₂))

infixl + : 65 := add
infixl - : 65 := sub
infixl * : 70 := mul
infixl / : 70 := div
prefix - : 100 := neg
infixr ^ : 80 := pow
infix ≤ : 50 := le
infix < : 50 := lt
infix ≥ : 50 := ge
infix > : 50 := gt

def add (n m : ℕ) : ℕ := rec n m succ
def mul (n m : ℕ) : ℕ := rec n zero (add m)

def bit0 (n : ℕ) : ℕ := n + n
def bit1 (n : ℕ) : ℕ := succ (bit0 n)

------------------------------------------------------------

/-

def split.{u, v} (f : u → v) : Prop := ∃ g, ∀ y, y = f (g y)

-- internal axiom of choice
lemma ac.{u, v} (f : u → v) : surjective f → split f

/-
lemma ac.{u, v} (R : u → v → Prop) : (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) :=
assume ∀ x, ∃ y, R x y,
exists.intro.{u → v}[(λ (f : u → v), ∀ x, R x (f x)), (λ (x : u), epsilon.{v} (λ y, R x y))]
-/

type def proof := { φ : Prop | φ }
def proof.target : proof → Prop := proof.rep

-- hypothetical lemma (using type dependency)
type def proof (φ : Prop) := { h : unit | φ }
lemma to_proof (φ : Prop) : φ → ∃! (h : proof φ), ⊤
lemma from_proof (φ : Prop) (h : proof φ) : φ

class comprehension u :=
  (type base : Type)
  (char : base → Prop)

namespace comprehension {
  const rep.{u} [comprehension u] : u → base u
  axiom rep.spec.{u} [comprehension u] : injective rep ∧ (∀ y, (∃! x, y = rep x) ↔ char y)
}

-- Diaconescu's argument: AC + prop_ext + fun_ext → EM
lemma em (φ : Prop) : φ ∨ ¬φ :=
let (U : Prop → Prop) := λ (ψ : Prop), φ ∨ ψ,
let (V : Prop → Prop) := λ (ψ : Prop), φ ∨ ¬ψ,
have exists U := exists.intro.{Prop}[U, ⊤] (or.right[φ, ⊤] top.intro),
have exists V := exists.intro.{Prop}[V, ⊥] (or.right[φ, ¬⊥] (assume ⊥, ⟪⊥⟫)),
let (u : Prop) := choice.{Prop} Prop.inhabited (exists U),
let (v : Prop) := choice.{Prop} Prop.inhabited (exists V),
have φ → u = v :=
  assume φ,
  have U = V := fun_ext (
    take ψ,
    have U ψ := or.left ⟪φ⟫,
    have V ψ := or.left ⟪φ⟫,
    have U ψ = V ψ := prop_ext (assume U ψ, ⟪V ψ⟫) (assume V ψ, ⟪U ψ⟫)
  ),
  eq.transport ⟪U = V⟫ eq.refl,
have φ ∨ u := choice.spec.{Prop}[Prop.inhabited, U] ⟪exists U⟫,
have φ ∨ ¬v := choice.spec.{Prop}[Prop.inhabited, V] ⟪exists V⟫,
have φ ∨ u ≠ v :=
  cases := ⟪φ ∨ u⟫,
  have φ,
    or.left ⟪φ⟫,
  have u,
    cases := ⟪φ ∨ ¬v⟫,
    have φ,
      or.left ⟪φ⟫,
    have ¬v,
      or.right (contradiction (assume u = v, eq.conv ⟪u = v⟫ u) ⟪¬v⟫),
cases := ⟪φ ∨ u ≠ v⟫,
  have φ,
    or.left ⟪φ⟫
  have u ≠ v,
    or.right (mt ⟪φ → u = v⟫ ⟪u ≠ v⟫),
-/
