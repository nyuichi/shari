infixr → : 25 := imp
infix = : 50 := eq
nofix ⊤ := top
infixr ∧ : 35 := and
nofix ⊥ := bot
infixr ∨ : 30 := or
prefix ¬ : 40 := not
infix ↔ : 20 := iff
infix ≠ : 50 := ne

-- Leibniz equality
def eq.{u} (x : u) (y : u) : Prop := ∀ P, P x → P y

def top : Prop := ∀ φ, φ → φ
def and (φ : Prop) (ψ : Prop) : Prop := ∀ ξ, (φ → ψ → ξ) → ξ

-- The following definitions are due to Prawitz and Russell.
def bot : Prop := ∀ ξ, ξ
def or (φ : Prop) (ψ : Prop) : Prop := ∀ ξ, (φ → ξ) → (ψ → ξ) → ξ
def exists.{u} (P : u → Prop) : Prop := ∀ ξ, (∀ x, P x → ξ) → ξ

-- Other connectives
def not (φ : Prop) : Prop := φ → ⊥
def iff (φ : Prop) (ψ : Prop) : Prop := (φ → ψ) ∧ (ψ → φ)
def uexists.{u} (P : u → Prop) : Prop := ∃ x, P x ∧ (∀ y, P y → x = y)
def ne.{u} (x : u) (y : u) : Prop := ¬x = y

-- Axioms of topos (cf. [Introduction to CATEGORY THEORY and CATEGORICAL LOGIC, T. Streicher, '03])
axiom prop_ext (φ ψ : Prop) : (φ ↔ ψ) → φ = ψ
axiom fun_ext.{u, v} (f₁ f₂ : u → v) : (∀ x, f₁ x = f₂ x) → f₁ = f₂
axiom auc.{u, v} (R : u → v → Prop) : (∀ x, ∃! y, R x y) → ∃! f, ∀ x, R x (f x)

/-
 - TODO:
 - * stronger type inference. (propagate constraints among exprs)
 - * automatic insertion of forall_elim using higher-order unification
 - * field access notation
 -/
lemma tautology : ∀ φ, φ → φ := take (φ : Prop), assume φ, ⟪φ⟫
lemma top.intro : ⊤ := tautology

lemma eq.refl.{u} (m : u) : m = m := take (P : u → Prop), tautology[P m]

lemma eq.transport.{u} (m₁ m₂ : u) (P : u → Prop) : m₁ = m₂ → P m₁ → P m₂ := assume m₁ = m₂, (change ∀ P, P m₁ → P m₂, ⟪m₁ = m₂⟫)[P]
lemma eq.symm.{u} (m₁ m₂ : u) : m₁ = m₂ → m₂ = m₁ := assume m₁ = m₂, eq.transport.{u}[_, _, λ m, m = m₁] ⟪m₁ = m₂⟫ eq.refl.{u}[m₁]
lemma eq.trans.{u} (m₁ m₂ m₃ : u) : m₁ = m₂ → m₂ = m₃ → m₁ = m₃ := assume m₁ = m₂, assume m₂ = m₃, eq.transport.{u}[_, _, λ m, m₁ = m] ⟪m₂ = m₃⟫ ⟪m₁ = m₂⟫
lemma and.intro (φ ψ : Prop) : φ → ψ → φ ∧ ψ := assume φ, assume ψ, take (ξ : Prop), assume φ → ψ → ξ, ⟪φ → ψ → ξ⟫ ⟪φ⟫ ⟪ψ⟫

-- modus ponens
lemma mp (φ ψ : Prop) : φ → (φ → ψ) → ψ := assume φ, assume φ → ψ, ⟪φ → ψ⟫ ⟪φ⟫
lemma imp.trans (φ ψ ξ : Prop) : (φ → ψ) → (ψ → ξ) → φ → ξ := assume φ → ψ, assume ψ → ξ, assume φ, ⟪ψ → ξ⟫ (⟪φ → ψ⟫ ⟪φ⟫)
-- modus tollens
lemma mt (φ ψ : Prop) : (φ → ψ) → ¬ψ → ¬φ := imp.trans[_, _, ⊥]
lemma contradiction (φ : Prop) : φ → ¬φ → ⊥ := mp[_, ⊥]
lemma absurd (φ : Prop) : ⊥ → φ := assume ⊥, (change ∀ ξ, ξ, ⟪⊥⟫)[φ]

lemma eq.conv (φ ψ : Prop) : (φ = ψ) → φ → ψ := assume φ = ψ, (eq.transport.{Prop}[_, _, λ (ξ : Prop), ξ] ⟪φ = ψ⟫)
-- material adequacy
lemma ma (φ : Prop) : (⊤ = φ) → φ := assume ⊤ = φ, eq.conv[_, _] ⟪⊤ = φ⟫ top.intro

lemma not.fixed_point_free (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ,
have ¬φ := assume φ, contradiction[φ] ⟪φ⟫ (eq.conv[_, _] ⟪φ = ¬φ⟫ ⟪φ⟫),
have φ := eq.conv[_, _] (eq.symm.{Prop}[_, _] ⟪φ = ¬φ⟫) ⟪¬φ⟫,
contradiction[φ] ⟪φ⟫ ⟪¬φ⟫

/-
lemma not.fixed_point_free (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ,
have ¬φ := assume φ, contradiction ⟪φ⟫ (⟪φ = ¬φ⟫.conv ⟪φ⟫),
have φ := ⟪φ = ¬φ⟫.symm.conv ⟪¬φ⟫,
contradiction ⟪φ⟫ ⟪¬φ⟫

lemma not.no_fixpoint (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ, show ⊥, {
  let φ, ¬φ := ⟪⊥⟫.contradiction φ,
  let (¬φ) = φ, ¬φ := ⟪φ⟫.apply eq.conv[¬φ, φ],    -- yields ¬φ, which is automatically contracted with the one that comes from the contradiction tactic.
  ⟪(¬φ) = φ⟫.symmetry := ⟪φ = ¬φ⟫,
  ⟪¬φ⟫ := assume φ, show ⊥, {
     let φ, ¬φ := ⟪⊥⟫.contradiction φ,
     let φ := ⟪¬φ⟫.apply (eq.conv[φ, ¬φ] ⟪φ = ¬φ⟫),   -- φ is automatically contracted.
     ⟪φ⟫ := ⟪φ⟫
  }
}
-/

lemma exists.intro.{u} (P : u → Prop) (m : u) : P m → exists P :=
assume P m,
take (ξ : Prop),
assume ∀ x, P x → ξ,
⟪∀ x, P x → ξ⟫[m] ⟪P m⟫

lemma exists.elim.{u} (P : u → Prop) (φ : Prop) : exists P → (∀ x, P x → φ) → φ :=
assume exists P,
(change ∀ ξ, (∀ x, P x → ξ) → ξ, ⟪exists P⟫)[φ]

lemma and.elim (φ ψ ξ : Prop) : φ ∧ ψ → (φ → ψ → ξ) → ξ :=
assume φ ∧ ψ,
(change ∀ ξ, (φ → ψ → ξ) → ξ, ⟪φ ∧ ψ⟫)[ξ]

lemma and.left (φ ψ : Prop) : φ ∧ ψ → φ :=
assume φ ∧ ψ,
(and.elim[_, _, _] ⟪φ ∧ ψ⟫) (assume φ, assume ψ, ⟪φ⟫)

lemma and.right (φ ψ : Prop) : φ ∧ ψ → ψ :=
assume φ ∧ ψ,
(and.elim[_, _, _] ⟪φ ∧ ψ⟫) (assume φ, assume ψ, ⟪ψ⟫)

lemma or.left (φ ψ : Prop) : φ → φ ∨ ψ :=
assume φ,
take (ξ : Prop),
assume φ → ξ,
assume ψ → ξ,
⟪φ → ξ⟫ ⟪φ⟫

lemma or.right (φ ψ : Prop) : ψ → φ ∨ ψ :=
assume ψ,
take (ξ : Prop),
assume φ → ξ,
assume ψ → ξ,
⟪ψ → ξ⟫ ⟪ψ⟫

lemma or.elim (φ ψ ξ : Prop) : φ ∨ ψ → (φ → ξ) → (ψ → ξ) → ξ :=
assume φ ∨ ψ,
(change ∀ ξ, (φ → ξ) → (ψ → ξ) → ξ, ⟪φ ∨ ψ⟫)[ξ]

lemma not.intro (φ : Prop) : (φ → ⊥) → ¬φ :=
assume φ → ⊥,
⟪φ → ⊥⟫

lemma not.elim (φ : Prop) : ¬φ → φ → ⊥ :=
assume ¬φ,
⟪¬φ⟫

lemma top_ne_bot : ⊤ ≠ ⊥ :=
assume ⊤ = ⊥,
eq.conv[_, _] ⟪⊤ = ⊥⟫ top.intro

lemma eq.ap.{u, v} (m₁ m₂ : u) (f : u → v) : m₁ = m₂ → f m₁ = f m₂ :=
assume m₁ = m₂,
eq.transport.{u}[_, _, λ x, f m₁ = f x] ⟪m₁ = m₂⟫ (eq.refl.{v}[f m₁])

lemma eq.congr_fun.{u, v} (f₁ f₂ : u → v) (x : u) : f₁ = f₂ → f₁ x = f₂ x :=
assume f₁ = f₂,
eq.transport.{u → v}[_, _, (λ (f : u → v), f₁ x = f x)] ⟪f₁ = f₂⟫ eq.refl.{v}[f₁ x]

lemma eq.congr_arg.{u, v} (f : u → v) (x₁ x₂ : u) : x₁ = x₂ → f x₁ = f x₂ :=
assume x₁ = x₂,
eq.transport.{u}[_, _, (λ x, f x₁ = f x)] ⟪x₁ = x₂⟫ eq.refl.{v}[f x₁]

-- subsingleton
def unique.{u} (P : u → Prop) : Prop := ∀ (x₁ x₂ : u), P x₁ → P x₂ → x₁ = x₂

lemma uexists.intro.{u} (P : u → Prop) : exists P → unique P → uexists P :=
assume exists P,
assume unique P,
obtain (x : u), P x := ⟪exists P⟫,
exists.intro.{u}[(λ x, P x ∧ ∀ y, P y → x = y), x] (and.intro[P x, ∀ y, P y → x = y] ⟪P x⟫ (take (y : u), assume P y, (change ∀ x₁ x₂, P x₁ → P x₂ → x₁ = x₂, ⟪unique P⟫)[x, y] ⟪P x⟫ ⟪P y⟫))

lemma uexists.exists.{u} (P : u → Prop) : uexists P → exists P :=
assume uexists P,
obtain (x : u), P x ∧ ∀ (y : u), P y → x = y := ⟪uexists P⟫,
exists.intro.{u}[P, x] (and.left[_, _] ⟪P x ∧ ∀ y, P y → x = y⟫)

lemma uexists.unique.{u} (P : u → Prop) : uexists P → unique P :=
assume uexists P,
take (x₁ : u),
take (x₂ : u),
assume P x₁,
assume P x₂,
obtain (x : u), P x ∧ ∀ y, P y → x = y := ⟪uexists P⟫,
have ∀ y, P y → x = y := and.right[P x, ∀ y, P y → x = y] ⟪P x ∧ ∀ y, P y → x = y⟫,
have x = x₁ := ⟪∀ y, P y → x = y⟫[x₁] ⟪P x₁⟫,
have x = x₂ := ⟪∀ y, P y → x = y⟫[x₂] ⟪P x₂⟫,
eq.trans.{u}[_, _, _] (eq.symm.{u}[_, _] ⟪x = x₁⟫) ⟪x = x₂⟫

lemma iff.intro (φ ψ : Prop) : (φ → ψ) → (ψ → φ) → (φ ↔ ψ) :=
assume φ → ψ,
assume ψ → φ,
and.intro[φ → ψ, ψ → φ] ⟪φ → ψ⟫ ⟪ψ → φ⟫

lemma iff.right (φ ψ : Prop) : (φ ↔ ψ) → φ → ψ :=
assume φ ↔ ψ,
and.left[_, _] ⟪φ ↔ ψ⟫

lemma iff.left (φ ψ : Prop) : (φ ↔ ψ) → ψ → φ :=
assume φ ↔ ψ,
and.right[_, _] ⟪φ ↔ ψ⟫

lemma exists.map.{u} (P Q : u → Prop) : (∀ x, P x → Q x) → (∃ x, P x) → ∃ x, Q x :=
assume ∀ x, P x → Q x,
assume ∃ x, P x,
obtain (t : u), P t := ⟪∃ x, P x⟫,
exists.intro.{u}[Q, t] (⟪∀ x, P x → Q x⟫[t] ⟪P t⟫)

lemma unique.map.{u} (P Q : u → Prop) : (∀ x, P x → Q x) → unique.{u} Q → unique.{u} P :=
assume ∀ x, P x → Q x,
assume unique.{u} Q,
take (x₁ : u),
take (x₂ : u),
assume P x₁,
assume P x₂,
(change ∀ x₁ x₂, Q x₁ → Q x₂ → x₁ = x₂, ⟪unique.{u} Q⟫)[x₁, x₂] (⟪∀ x, P x → Q x⟫[x₁] ⟪P x₁⟫) (⟪∀ x, P x → Q x⟫[x₂] ⟪P x₂⟫)

lemma uexists.congr.{u} (P Q : u → Prop) : (∀ x, P x ↔ Q x) → ((∃! x, P x) ↔ ∃! x, Q x) :=
assume ∀ x, P x ↔ Q x,
have ∀ x, P x → Q x := take (x : u), iff.right[_, _] ⟪∀ x, P x ↔ Q x⟫[x],
have ∀ x, Q x → P x := take (x : u), iff.left[_, _] ⟪∀ x, P x ↔ Q x⟫[x],
iff.intro[(∃! x, P x), (∃! y, Q y)]
  (assume ∃! x, P x,
    uexists.intro.{u}[Q]
      (exists.map.{u}[P, Q] ⟪∀ x, P x → Q x⟫ (uexists.exists.{u}[P] ⟪∃! x, P x⟫))
      (unique.map.{u}[Q, P] ⟪∀ x, Q x → P x⟫ (uexists.unique.{u}[P] ⟪∃! x, P x⟫)))
  (assume ∃! x, Q x,
    uexists.intro.{u}[P]
      (exists.map.{u}[Q, P] ⟪∀ x, Q x → P x⟫ (uexists.exists.{u}[Q] ⟪∃! x, Q x⟫))
      (unique.map.{u}[P, Q] ⟪∀ x, P x → Q x⟫ (uexists.unique.{u}[Q] ⟪∃! x, Q x⟫)))

/-
 - Extensionality
 -/

lemma eq.congr_abs.{u, v} (m₁ m₂ : u) : (∀ (x : v), m₁ = m₂) → (λ (x : v), m₁) = (λ (x : v), m₂) :=
assume ∀ (x : v), m₁ = m₂,
fun_ext.{v, u}[(λ (x : v), m₁), (λ (x : v), m₂)] ⟪∀ (x : v), m₁ = m₂⟫

lemma eta_expand.{u, v} (f : u → v) : f = λ (x : u), f x :=
fun_ext.{u, v}[f, λ x, f x] (take (x : u), eq.refl.{v}[f x])

/-
 - functions
 -/

def injective.{u, v} (f : u → v) : Prop := ∀ x y, f x = f y → x = y
def surjective.{u, v} (f : u → v) : Prop := ∀ y, ∃ x, y = f x

lemma lawvere_fixpoint.{u, v} : (∃ (e : u → u → v), surjective e) → ∀ (f : v → v), ∃ y, y = f y :=
assume ∃ (e : u → u → v), surjective e,
take (f : v → v),
obtain (e : u → u → v), surjective e := ⟪∃ (e : u → u → v), surjective e⟫,
obtain (x : u), (λ x, f (e x x)) = e x := (change ∀ g, ∃ x, g = e x, ⟪surjective e⟫)[λ x, f (e x x)],
have f (e x x) = e x x := eq.congr_fun.{u, v}[_, _, x] ⟪(λ x, f (e x x)) = e x⟫,
exists.intro.{v}[(λ y, y = f y), e x x] (eq.symm.{v}[_, _] ⟪f (e x x) = e x x⟫)

lemma cantor.{u} : ¬(∃ (e : u → u → Prop), surjective e) :=
mt[(∃ (e : u → u → Prop), surjective e), ∀ (f : Prop → Prop), ∃ y, y = f y] lawvere_fixpoint.{u, Prop} (
    assume ∀ (f : Prop → Prop), ∃ y, y = f y,
    obtain (y : Prop), y = ¬y := ⟪∀ (f : Prop → Prop), ∃ y, y = f y⟫[not],
    contradiction[y = ¬y] ⟪y = ¬y⟫ (not.fixed_point_free[y]))

lemma injective.unique.{u, v} (f : u → v) : injective f → ∀ y, unique (λ x, y = f x) :=
assume injective f,
take (y : v),
take (x₁ : u),
take (x₂ : u),
assume y = f x₁,
assume y = f x₂,
(change ∀ x y, f x = f y → x = y, ⟪injective f⟫)[x₁, x₂] (eq.trans.{v}[_, _, _] (eq.symm.{v}[_, _] ⟪y = f x₁⟫) ⟪y = f x₂⟫)

/-
 - comprehension types
 -/

-- e.g. type def bool := { x : Prop | x = ⊤ ∨ x = ⊥ } yields comprehension.{Prop, bool}
type const comprehension : Type → Type → Type
const char.{v, u} : comprehension v u → v → Prop
const rep.{v, u} : comprehension v u → u → v
axiom rep.spec.{v, u} (d : comprehension v u) : injective (rep d) ∧ (∀ y, char d y ↔ ∃! x, y = rep d x)

lemma rep.injective.{v, u} (d : comprehension v u) : injective (rep d) :=
and.left[_, _] rep.spec.{v, u}[d]

lemma rep.unique.{v, u} (d : comprehension v u) (y : v) : unique (λ x, y = rep d x) :=
(injective.unique.{u, v}[rep d] rep.injective.{v, u}[d])[y]

lemma rep.iff_char.{v, u} (d : comprehension v u) (y : v) : char d y ↔ ∃! x, y = rep d x :=
(and.right[_, _] rep.spec.{v, u}[d])[y]

lemma rep.char.{v, u} (d : comprehension v u) (y : v) : (∃! x, y = rep d x) → char d y :=
iff.left[_, _] rep.iff_char.{v, u}[d, y]

lemma char.abs.{v, u} (d : comprehension v u) (y : v) : char d y → ∃! x, y = rep d x :=
iff.right[_, _] rep.iff_char.{v, u}[d, y]

lemma char.rep.{v, u} (d : comprehension v u) (x : u) : char d (rep d x) :=
rep.char.{v, u}[d, rep d x] (uexists.intro.{u}[λ z, rep d x = rep d z] (exists.intro.{u}[(λ z, rep d x = rep d z), x] eq.refl.{v}[rep d x]) rep.unique.{v, u}[d, rep d x])

lemma comprehension.ind.{v, u} (d : comprehension v u) (P : u → Prop) : (∀ (y : v) (x : u), y = rep d x → P x) → ∀ x, P x :=
assume ∀ (y : v) (x : u), y = rep d x → P x,
take (x : u),
⟪∀ (y : v) (x : u), y = rep d x → P x⟫[rep d x, x] eq.refl.{v}[rep d x]

/-
 - bool
 -/

-- The type of decidable propositions.
-- type def bool := { φ : Prop | φ = ⊤ ∨ φ = ⊥ }
type const bool : Type
const bool.comprehension : comprehension Prop bool
def bool.char : Prop → Prop := λ φ, φ = ⊤ ∨ φ = ⊥
axiom bool.spec : bool.char = char bool.comprehension
lemma bool.char.unfold (φ : Prop) : bool.char φ → char bool.comprehension φ := assume bool.char φ, eq.conv[_, _] (eq.congr_fun.{Prop, Prop}[_, _, φ] bool.spec) ⟪bool.char φ⟫
lemma bool.char.fold (φ : Prop) : char bool.comprehension φ → bool.char φ := assume char bool.comprehension φ, eq.conv[_, _] (eq.congr_fun.{Prop, Prop}[_, _, φ] (eq.symm.{Prop → Prop}[_, _] bool.spec)) ⟪char bool.comprehension φ⟫
def bool.rep : bool → Prop := rep bool.comprehension
lemma bool.char.abs (φ : Prop) : bool.char φ → ∃! x, φ = bool.rep x := assume bool.char φ, char.abs.{Prop, bool}[bool.comprehension, φ] (bool.char.unfold[φ] ⟪bool.char φ⟫)
lemma bool.rep.char (φ : Prop) : (∃! x, φ = bool.rep x) → bool.char φ := assume ∃! x, φ = bool.rep x, bool.char.fold[φ] (rep.char.{Prop, bool}[bool.comprehension, φ] ⟪∃! x, φ = bool.rep x⟫)
lemma bool.char.rep (x : bool) : bool.char (bool.rep x) := bool.char.fold[bool.rep x] char.rep.{Prop, bool}[bool.comprehension, x]
lemma bool.comprehension.ind (P : bool → Prop) : (∀ (φ : Prop) (x : bool), φ = bool.rep x → P x) → ∀ x, P x := comprehension.ind.{Prop, bool}[bool.comprehension, P]
lemma bool.rep.injective : injective bool.rep := rep.injective.{Prop, bool}[bool.comprehension]

lemma bool.tt_uexists : ∃! (tt : bool), ⊤ = bool.rep tt :=
bool.char.abs[⊤] (or.left[⊤ = ⊤, ⊤ = ⊥] eq.refl.{Prop}[⊤])

lemma bool.ff_uexists : ∃! (ff : bool), ⊥ = bool.rep ff :=
bool.char.abs[⊥] (or.right[⊥ = ⊤, ⊥ = ⊥] eq.refl.{Prop}[⊥])


-- def (tt : bool), ⊤ = bool.rep tt := bool.tt.uexists
-- def (ff : bool), ⊥ = bool.rep ff := bool.ff.uexists
const tt : bool
axiom tt.spec : ⊤ = bool.rep tt
const ff : bool
axiom ff.spec : ⊥ = bool.rep ff

lemma bool.ind (P : bool → Prop) : P tt → P ff → ∀ b, P b :=
assume P tt,
assume P ff,
bool.comprehension.ind[P] (
  take (φ : Prop),
  take (b : bool),
  assume φ = bool.rep b,
  have φ = ⊤ ∨ φ = ⊥ := eq.transport.{Prop}[bool.rep b, φ, bool.char] (eq.symm.{Prop}[φ, bool.rep b] ⟪φ = bool.rep b⟫) bool.char.rep[b],
  or.elim[φ = ⊤, φ = ⊥, P b] ⟪φ = ⊤ ∨ φ = ⊥⟫
    (assume φ = ⊤,
      have bool.rep tt = bool.rep b := eq.trans.{Prop}[bool.rep tt, ⊤, bool.rep b] (eq.symm.{Prop}[⊤, bool.rep tt] tt.spec) (eq.trans.{Prop}[⊤, φ, bool.rep b] (eq.symm.{Prop}[φ, ⊤] ⟪φ = ⊤⟫) ⟪φ = bool.rep b⟫),
      have tt = b := (change ∀ x y, bool.rep x = bool.rep y → x = y, bool.rep.injective)[tt, b] ⟪bool.rep tt = bool.rep b⟫,
      eq.transport.{bool}[tt, b, P] ⟪tt = b⟫ ⟪P tt⟫)
    (assume φ = ⊥,
      have bool.rep ff = bool.rep b := eq.trans.{Prop}[bool.rep ff, ⊥, bool.rep b] (eq.symm.{Prop}[⊥, bool.rep ff] ff.spec) (eq.trans.{Prop}[⊥, φ, bool.rep b] (eq.symm.{Prop}[φ, ⊥] ⟪φ = ⊥⟫) ⟪φ = bool.rep b⟫),
      have ff = b := (change ∀ x y, bool.rep x = bool.rep y → x = y, bool.rep.injective)[ff, b] ⟪bool.rep ff = bool.rep b⟫,
      eq.transport.{bool}[ff, b, P] ⟪ff = b⟫ ⟪P ff⟫))

lemma bool.case : ∀ b, b = tt ∨ b = ff :=
bool.ind[λ b, b = tt ∨ b = ff] (or.left[tt = tt, tt = ff] eq.refl.{bool}[tt]) (or.right[ff = tt, ff = ff] eq.refl.{bool}[ff])

lemma bool.tt_ne_ff : tt ≠ ff :=
assume tt = ff,
(change (⊤ = ⊥) → ⊥, top_ne_bot) (eq.trans.{Prop}[⊤, bool.rep tt, ⊥] tt.spec (eq.trans.{Prop}[bool.rep tt, bool.rep ff, ⊥] (eq.congr_arg.{bool, Prop}[bool.rep, tt, ff] ⟪tt = ff⟫) (eq.symm.{Prop}[⊥, bool.rep ff] ff.spec)))

lemma bool.rec_exists.{u} (on_tt : u) (on_ff : u) (b : bool) : ∃ (rec : u), (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff) :=
or.elim[b = tt, b = ff, ∃ rec, (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff)] bool.case[b]
  (assume b = tt,
    exists.intro.{u}[(λ rec, (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff)), on_tt]
      (and.intro[b = tt → on_tt = on_tt, b = ff → on_tt = on_ff]
        (assume b = tt, eq.refl.{u}[on_tt])
        (assume b = ff, absurd[on_tt = on_ff] ((change tt = ff → ⊥, bool.tt_ne_ff) (eq.trans.{bool}[tt, b, ff] (eq.symm.{bool}[b, tt] ⟪b = tt⟫) ⟪b = ff⟫)))))
  (assume b = ff,
    exists.intro.{u}[(λ rec, (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff)), on_ff]
      (and.intro[b = tt → on_ff = on_tt, b = ff → on_ff = on_ff]
        (assume b = tt, absurd[on_ff = on_tt] ((change tt = ff → ⊥, bool.tt_ne_ff) (eq.trans.{bool}[tt, b, ff] (eq.symm.{bool}[b, tt] ⟪b = tt⟫) ⟪b = ff⟫)))
        (assume b = ff, eq.refl.{u}[on_ff])))

lemma bool.rec_unique.{u} (on_tt : u) (on_ff : u) (b : bool) : unique λ (rec : u), (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff) :=
take (r₁ : u),
take (r₂ : u),
assume (b = tt → r₁ = on_tt) ∧ (b = ff → r₁ = on_ff),
assume (b = tt → r₂ = on_tt) ∧ (b = ff → r₂ = on_ff),
or.elim[b = tt, b = ff, r₁ = r₂] bool.case[b]
  (assume b = tt,
    have r₁ = on_tt := and.left[b = tt → r₁ = on_tt, b = ff → r₁ = on_ff] ⟪(b = tt → r₁ = on_tt) ∧ (b = ff → r₁ = on_ff)⟫ ⟪b = tt⟫,
    have r₂ = on_tt := and.left[b = tt → r₂ = on_tt, b = ff → r₂ = on_ff] ⟪(b = tt → r₂ = on_tt) ∧ (b = ff → r₂ = on_ff)⟫ ⟪b = tt⟫,
    eq.trans.{u}[r₁, on_tt, r₂] ⟪r₁ = on_tt⟫ (eq.symm.{u}[r₂, on_tt] ⟪r₂ = on_tt⟫))
  (assume b = ff,
    have r₁ = on_ff := and.right[b = tt → r₁ = on_tt, b = ff → r₁ = on_ff] ⟪(b = tt → r₁ = on_tt) ∧ (b = ff → r₁ = on_ff)⟫ ⟪b = ff⟫,
    have r₂ = on_ff := and.right[b = tt → r₂ = on_tt, b = ff → r₂ = on_ff] ⟪(b = tt → r₂ = on_tt) ∧ (b = ff → r₂ = on_ff)⟫ ⟪b = ff⟫,
    eq.trans.{u}[r₁, on_ff, r₂] ⟪r₁ = on_ff⟫ (eq.symm.{u}[r₂, on_ff] ⟪r₂ = on_ff⟫))

lemma bool.rec_uexists.{u} (on_tt : u) (on_ff : u) (b : bool) : ∃! (rec : u), (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff) :=
uexists.intro.{u}[λ (rec : u), (b = tt → rec = on_tt) ∧ (b = ff → rec = on_ff)] bool.rec_exists.{u}[on_tt, on_ff, b] bool.rec_unique.{u}[on_tt, on_ff, b]

-- def (rec.{u} (on_tt : u) (on_ff : u) (b : bool) : u), (b = tt → rec on_tt on_ff b = on_tt) ∧ (b = ff → rec on_tt on_ff b = on_ff) := bool.rec_uexists.{u}
const bool.rec.{u} : u → u → bool → u
axiom bool.rec.spec.{u} (on_tt : u) (on_ff : u) (b : bool) : (b = tt → bool.rec.{u} on_tt on_ff b = on_tt) ∧ (b = ff → bool.rec.{u} on_tt on_ff b = on_ff)

def bool.cond.{u} (b : bool) (then : u) (else : u) : u := bool.rec.{u} then else b

/-
 - unit
 -/

-- type def unit := { φ : Prop | ⊤ = φ }
-- We do not use { φ | φ } in the definition because prop_ext is necessary for unit to have only one element.
type const unit : Type
const unit.comprehension : comprehension Prop unit
def unit.char : Prop → Prop := λ φ, ⊤ = φ
axiom unit.spec : unit.char = char unit.comprehension
lemma unit.char.unfold (φ : Prop) : unit.char φ → char unit.comprehension φ := assume unit.char φ, eq.conv[unit.char φ, char unit.comprehension φ] (eq.congr_fun.{Prop, Prop}[unit.char, char unit.comprehension, φ] unit.spec) ⟪unit.char φ⟫
lemma unit.char.fold (φ : Prop) : char unit.comprehension φ → unit.char φ := assume char unit.comprehension φ, eq.conv[char unit.comprehension φ, unit.char φ] (eq.congr_fun.{Prop, Prop}[char unit.comprehension, unit.char, φ] (eq.symm.{Prop → Prop}[unit.char, char unit.comprehension] unit.spec)) ⟪char unit.comprehension φ⟫
def unit.rep : unit → Prop := rep unit.comprehension
lemma unit.char.abs (φ : Prop) : unit.char φ → ∃! x, φ = unit.rep x := assume unit.char φ, char.abs.{Prop, unit}[unit.comprehension, φ] (unit.char.unfold[φ] ⟪unit.char φ⟫)
lemma unit.rep.char (φ : Prop) : (∃! x, φ = unit.rep x) → unit.char φ := assume ∃! x, φ = unit.rep x, unit.char.fold[φ] (rep.char.{Prop, unit}[unit.comprehension, φ] ⟪∃! x, φ = unit.rep x⟫)
lemma unit.char.rep (x : unit) : unit.char (unit.rep x) := unit.char.fold[unit.rep x] char.rep.{Prop, unit}[unit.comprehension, x]
lemma unit.comprehension.ind (P : unit → Prop) : (∀ (φ : Prop) (x : unit), φ = unit.rep x → P x) → ∀ x, P x := comprehension.ind.{Prop, unit}[unit.comprehension, P]
lemma unit.rep.injective : injective unit.rep := rep.injective.{Prop, unit}[unit.comprehension]

lemma unit.star_uexists : ∃! (star : unit), ⊤ = unit.rep star :=
unit.char.abs[⊤] eq.refl.{Prop}[⊤]

-- def (star : unit), ⊤ = unit.rep star := unit.star_uexists
const star : unit
axiom star.spec : ⊤ = unit.rep star

lemma unit.unique (x y : unit) : x = y :=
have unit.rep x = unit.rep y := eq.trans.{Prop}[unit.rep x, ⊤, unit.rep y] (eq.symm.{Prop}[⊤, unit.rep x] unit.char.rep[x]) unit.char.rep[y],
(change ∀ x y, unit.rep x = unit.rep y → x = y, unit.rep.injective)[x, y] ⟪unit.rep x = unit.rep y⟫

lemma unit.eta_expand (x : unit) : x = star :=
unit.unique[x, star]

lemma unit.eta_reduce (x : unit) : star = x :=
unit.unique[star, x]

lemma unit.ind (P : unit → Prop) : P star → ∀ (x : unit), P x :=
assume P star,
take (x : unit),
eq.transport.{unit}[star, x, P] unit.eta_reduce[x] ⟪P star⟫

/-
 - support
 -/

-- a.k.a. the bracket type, or the propositional truncation
-- type support u := { x : unit | ∃ (a : u), ⊤ }
type const support : Type → Type
const support.comprehension.{u} : comprehension unit (support u)
def support.char.{u} : unit → Prop := λ x, ∃ (a : u), ⊤
axiom support.spec.{u} : support.char.{u} = char support.comprehension.{u}
lemma support.char.unfold.{u} (x : unit) : support.char.{u} x → char support.comprehension.{u} x := assume support.char.{u} x, eq.conv[support.char.{u} x, char support.comprehension.{u} x] (eq.congr_fun.{unit, Prop}[support.char.{u}, char support.comprehension.{u}, x] support.spec.{u}) ⟪support.char.{u} x⟫
lemma support.char.fold.{u} (x : unit) : char support.comprehension.{u} x → support.char.{u} x := assume char support.comprehension.{u} x, eq.conv[char support.comprehension.{u} x, support.char.{u} x] (eq.congr_fun.{unit, Prop}[char support.comprehension.{u}, support.char.{u}, x] (eq.symm.{unit → Prop}[support.char.{u}, char support.comprehension.{u}] support.spec.{u})) ⟪char support.comprehension.{u} x⟫
def support.rep.{u} : support u → unit := rep support.comprehension.{u}
lemma support.char.abs.{u} (x : unit) : support.char.{u} x → ∃! h, x = support.rep.{u} h := assume support.char.{u} x, char.abs.{unit, support u}[support.comprehension.{u}, x] (support.char.unfold.{u}[x] ⟪support.char.{u} x⟫)
lemma support.rep.char.{u} (x : unit) : (∃! h, x = support.rep.{u} h) → support.char.{u} x := assume ∃! h, x = support.rep.{u} h, support.char.fold.{u}[x] (rep.char.{unit, support u}[support.comprehension.{u}, x] ⟪∃! h, x = support.rep.{u} h⟫)
lemma support.char.rep.{u} (h : support u) : support.char.{u} (support.rep.{u} h) := support.char.fold.{u}[support.rep.{u} h] char.rep.{unit, support u}[support.comprehension.{u}, h]
lemma support.comprehension.ind.{u} (P : support u → Prop) : (∀ (x : unit) (h : support u), x = support.rep.{u} h → P h) → ∀ h, P h := comprehension.ind.{unit, support u}[support.comprehension.{u}, P]
lemma support.rep.injective.{u} : injective support.rep.{u} := rep.injective.{unit, support u}[support.comprehension.{u}]

lemma support.char.unfold_.{u} : support.char.{u} star → char support.comprehension.{u} star := assume support.char.{u} star, eq.conv[support.char.{u} star, char support.comprehension.{u} star] (eq.congr_fun.{unit, Prop}[support.char.{u}, char support.comprehension.{u}, star] support.spec.{u}) ⟪support.char.{u} star⟫
lemma support.char.fold_.{u} : char support.comprehension.{u} star → support.char.{u} star := assume char support.comprehension.{u} star, eq.conv[char support.comprehension.{u} star, support.char.{u} star] (eq.congr_fun.{unit, Prop}[char support.comprehension.{u}, support.char.{u}, star] (eq.symm.{unit → Prop}[support.char.{u}, char support.comprehension.{u}] support.spec.{u})) ⟪char support.comprehension.{u} star⟫
lemma support.char.help.{u} : (∃! (h : support u), ⊤) ↔ (∃! (h : support u), star = support.rep.{u} h) :=
(uexists.congr.{support u}[(λ (h : support u), ⊤), (λ h, star = support.rep.{u} h)]
  (take (h : support u),
    iff.intro[⊤, star = support.rep.{u} h]
      (assume ⊤,
        unit.eta_reduce[support.rep.{u} h])
      (assume star = support.rep.{u} h,
        top.intro)))
lemma support.char.abs_.{u} : support.char.{u} star → ∃! (h : support u), ⊤ :=
assume support.char.{u} star,
iff.left[(∃! (h : support u), ⊤), (∃! (h : support u), star = support.rep.{u} h)]
  support.char.help.{u}
  (support.char.abs.{u}[star] ⟪support.char.{u} star⟫)
lemma support.rep.char_.{u} : (∃! (h : support u), ⊤) → support.char.{u} star :=
assume ∃! (h : support u), ⊤,
have ∃! (h : support u), star = support.rep.{u} h :=
  iff.right[(∃! (h : support u), ⊤), (∃! (h : support u), star = support.rep.{u} h)] support.char.help.{u} ⟪∃! (h : support u), ⊤⟫,
support.rep.char.{u}[star] ⟪∃! (h : support u), star = support.rep.{u} h⟫
lemma support.char.rep_.{u} (h : support u) : support.char.{u} star := support.char.rep.{u}[h]

lemma support.mk_uexists.{u} (x : u) : ∃! (mk : support u), ⊤ :=
have ∃ (x : u), ⊤ :=
  exists.intro.{u}[λ (x : u), ⊤, x] top.intro,
support.char.abs_.{u} ⟪∃ (x : u), ⊤⟫

-- def (support.mk.{u} (x : u) : support u), ⊤ := support.mk_uexists.{u}[x]
const support.mk.{u} : u → support u

lemma support.unique.{u} (h₁ h₂ : support u) : h₁ = h₂ :=
(change ∀ h₁ h₂, support.rep.{u} h₁ = support.rep.{u} h₂ → h₁ = h₂, support.rep.injective.{u})[h₁, h₂] unit.unique[support.rep.{u} h₁, support.rep.{u} h₂]

lemma support.exists_imp_uexists.{u} (P : support u → Prop) : (∃ h, P h) → ∃! h, P h :=
assume ∃ h, P h,
uexists.intro.{support u}[P]
  ⟪∃ h, P h⟫
  (take (h₁ : support u), take (h₂ : support u), assume P h₁, assume P h₂, support.unique.{u}[h₁, h₂])

lemma support.join_uexists.{u} (h : support (support u)) : ∃! (h : support u), ⊤ :=
support.exists_imp_uexists.{u}[λ (h : support u), ⊤] support.char.rep_.{support u}[h]

-- def (support.join.{u} (h : support (support u)) : support u), ⊤ := support.join_uexists.{u}[h]
const support.join.{u} : support (support u) → support u

-- internal global choice operator
-- 
-- Introducing this constant restricts the class of models to toposes whose supports split.
-- Note we do not have an object-level function assigning for each type u the choice function,
-- which would imply axiom of choice.
-- In (dependent) type theory, this operator corresponds via the propositions-as-types paradigm
-- to the law of double negation.
const choice.{u} : support u → u

------------------------------------------------------------

/-

inductive inhabited (u : Type) :=
| mk :: u → inhabited u

type const inhabited : Type → Type
const inhabited.mk.{u} : u → inhabited u
const inhabited.rec.{u, v} : inhabited u → (u → v) → v
axiom inhabited.rec.spec.{u, v} (x : u) (f : u → v) : inhabited.rec.{u, v} (inhabited.mk.{u} x) f = f x

instance Prop.inhabited : inhabited Prop := inhabited.mk.{Prop} ⊤

def Prop.inhabited : inhabited Prop := inhabited.mk.{Prop} ⊤

const epsilon.{u} : inhabited u → (u → Prop) → u
axiom epsilon.spec.{u} (h : inhabited u) (P : u → Prop) : (∃ x, P x) → P (epsilon.{u} h P)

lemma epsilon.singleton.{u} (x : u) : epsilon.{u} (inhabited.mk.{u} x) (λ y, y = x) = x :=
epsilon.spec.{u}[inhabited.mk.{u} x, (λ y, y = x)] (exists.intro.{u}[(λ y, y = x), x] eq.refl.{u}[x])

-- internal axiom of choice
lemma ac.{u, v} (f : u → v) : surjective f → ∃ g, ∀ y, y = f (g y)

/-
lemma ac.{u, v} (R : u → v → Prop) : (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) :=
assume ∀ x, ∃ y, R x y,
exists.intro.{u → v}[(λ (f : u → v), ∀ x, R x (f x)), (λ (x : u), epsilon.{v} (λ y, R x y))]
-/

type def proof := { φ : Prop | φ }
def proof.target : proof → Prop := proof.rep

-- hypothetical lemma (using type dependency)
type def proof (φ : Prop) := { h : unit | φ }
lemma to_proof (φ : Prop) : φ → ∃! (h : proof φ), ⊤
lemma from_proof (φ : Prop) (h : proof φ) : φ

// axiom foo : φ
//
// check foo : support { x : unit | φ }
//
// def epsilon (P : u → Prop) : support { x : u | P x } → { x : u | P x } := choice.{{ x : u | P x }}

class comprehension u :=
  (type base : Type)
  (char : base → Prop)

namespace comprehension {
  const rep.{u} [comprehension u] : u → base u
  axiom rep.spec.{u} [comprehension u] : injective rep ∧ (∀ y, (∃! x, y = rep x) ↔ char y)
}

ac : (∀ (X : { X : Prop → Prop | X = U ∨ X = V }), ∃ y, X y) → ∃ (f : { X : Prop → Prop | X = U ∨ X = V } → Prop), ∀ (X : { X : Prop → Prop | X = U ∨ X = V }), X (f X)

-- Diaconescu's argument: AC + prop_ext + fun_ext → EM
lemma em (φ : Prop) : φ ∨ ¬φ :=
let (U : Prop → Prop) := λ (ψ : Prop), φ ∨ ψ,
let (V : Prop → Prop) := λ (ψ : Prop), φ ∨ ¬ψ,
have exists U := exists.intro.{Prop}[U, ⊤] (or.right[φ, ⊤] top.intro),
have exists V := exists.intro.{Prop}[V, ⊥] (or.right[φ, ¬⊥] (assume ⊥, ⟪⊥⟫)),
let (u : Prop) := choice.{Prop} Prop.inhabited (exists U),
let (v : Prop) := choice.{Prop} Prop.inhabited (exists V),
have φ → u = v :=
  assume φ,
  have U = V := fun_ext (
    take ψ,
    have U ψ := or.left ⟪φ⟫,
    have V ψ := or.left ⟪φ⟫,
    have U ψ = V ψ := prop_ext (assume U ψ, ⟪V ψ⟫) (assume V ψ, ⟪U ψ⟫)
  ),
  eq.transport ⟪U = V⟫ eq.refl,
have φ ∨ u := choice.spec.{Prop}[Prop.inhabited, U] ⟪exists U⟫,
have φ ∨ ¬v := choice.spec.{Prop}[Prop.inhabited, V] ⟪exists V⟫,
have φ ∨ u ≠ v :=
  cases := ⟪φ ∨ u⟫,
  have φ,
    or.left ⟪φ⟫,
  have u,
    cases := ⟪φ ∨ ¬v⟫,
    have φ,
      or.left ⟪φ⟫,
    have ¬v,
      or.right (contradiction (assume u = v, eq.conv ⟪u = v⟫ u) ⟪¬v⟫),
cases := ⟪φ ∨ u ≠ v⟫,
  have φ,
    or.left ⟪φ⟫
  have u ≠ v,
    or.right (mt ⟪φ → u = v⟫ ⟪u ≠ v⟫),
-/
