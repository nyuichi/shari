infixr ⇒ : 25 := imp
infix = : 50 := eq
nofix ⊤ := top
infixr ∧ : 35 := and
nofix ⊥ := bot
infixr ∨ : 30 := or
prefix ¬ : 40 := not
infix ⇔ : 20 := iff
infix ≠ : 50 := ne

-- Leibniz equality
def eq.{u} (x : u) (y : u) : Prop := ∀ P, P x ⇒ P y

def top : Prop := ∀ φ, φ ⇒ φ
def and (φ : Prop) (ψ : Prop) : Prop := ∀ ξ, (φ ⇒ ψ ⇒ ξ) ⇒ ξ

-- The following definitions are due to Prawitz and Russell.
def bot : Prop := ∀ ξ, ξ
def or (φ : Prop) (ψ : Prop) : Prop := ∀ ξ, (φ ⇒ ξ) ⇒ (ψ ⇒ ξ) ⇒ ξ
def exists.{u} (P : u → Prop) : Prop := ∀ ξ, (∀ x, P x ⇒ ξ) ⇒ ξ

-- Other connectives
def not (φ : Prop) : Prop := φ ⇒ ⊥
def iff (φ : Prop) (ψ : Prop) : Prop := (φ ⇒ ψ) ∧ (ψ ⇒ φ)
def uexists.{u} (P : u → Prop) : Prop := ∃ x, P x ∧ (∀ y, P y ⇒ x = y)
def ne.{u} (x : u) (y : u) : Prop := ¬x = y

-- Axioms of topos (cf. [Introduction to CATEGORY THEORY and CATEGORICAL LOGIC, T. Streicher, '03])
axiom prop_ext (φ ψ : Prop) : (φ ⇔ ψ) ⇒ φ = ψ
axiom fun_ext.{u, v} (f₁ f₂ : u → v) : (∀ x, f₁ x = f₂ x) ⇒ f₁ = f₂
axiom auc.{u, v} (R : u → v → Prop) : (∀ x, ∃! y, R x y) ⇒ ∃! f, ∀ x, R x (f x)

/-
 - TODO:
 - * stronger type inference. (propagate constraints among exprs)
 - * automatic insertion of forall_elim using higher-order unification
 - * field access notation
 -/
lemma tautology : ∀ φ, φ ⇒ φ := take (φ : Prop), assume φ, ⟪φ⟫
lemma top.intro : ⊤ := tautology

lemma eq.refl.{u} (m : u) : m = m := take (P : u → Prop), tautology[P m]

lemma eq.transport.{u} (m₁ m₂ : u) (P : u → Prop) : m₁ = m₂ ⇒ P m₁ ⇒ P m₂ :=
assume m₁ = m₂,
(change ∀ P, P m₁ ⇒ P m₂, ⟪m₁ = m₂⟫)[P]

lemma eq.symm.{u} (m₁ m₂ : u) : m₁ = m₂ ⇒ m₂ = m₁ := assume m₁ = m₂, eq.transport.{u}[m₁, m₂, λ m, m = m₁] ⟪m₁ = m₂⟫ eq.refl.{u}[m₁]
lemma eq.trans.{u} (m₁ m₂ m₃ : u) : m₁ = m₂ ⇒ m₂ = m₃ ⇒ m₁ = m₃ := assume m₁ = m₂, assume m₂ = m₃, eq.transport.{u}[m₂, m₃, λ m, m₁ = m] ⟪m₂ = m₃⟫ ⟪m₁ = m₂⟫
lemma and.intro (φ ψ : Prop) : φ ⇒ ψ ⇒ φ ∧ ψ := assume φ, assume ψ, take (ξ : Prop), assume φ ⇒ ψ ⇒ ξ, ⟪φ ⇒ ψ ⇒ ξ⟫ ⟪φ⟫ ⟪ψ⟫

-- modus ponens
lemma mp (φ ψ : Prop) : φ ⇒ (φ ⇒ ψ) ⇒ ψ := assume φ, assume φ ⇒ ψ, ⟪φ ⇒ ψ⟫ ⟪φ⟫
lemma imp.trans (φ ψ ξ : Prop) : (φ ⇒ ψ) ⇒ (ψ ⇒ ξ) ⇒ φ ⇒ ξ := assume φ ⇒ ψ, assume ψ ⇒ ξ, assume φ, ⟪ψ ⇒ ξ⟫ (⟪φ ⇒ ψ⟫ ⟪φ⟫)
-- modus tollens
lemma mt (φ ψ : Prop) : (φ ⇒ ψ) ⇒ ¬ψ ⇒ ¬φ := imp.trans[φ, ψ, ⊥]
lemma contradiction (φ : Prop) : φ ⇒ ¬φ ⇒ ⊥ := mp[φ, ⊥]
lemma absurd (φ : Prop) : ⊥ ⇒ φ := assume ⊥, (change ∀ ξ, ξ, ⟪⊥⟫)[φ]

lemma eq.conv (φ ψ : Prop) : (φ = ψ) ⇒ φ ⇒ ψ := assume φ = ψ, (eq.transport.{Prop}[φ, ψ, λ (ξ : Prop), ξ] ⟪φ = ψ⟫)
-- material adequacy
lemma ma (φ : Prop) : (φ = ⊤) ⇒ φ := assume φ = ⊤, eq.conv[⊤, φ] (eq.symm.{Prop}[φ, ⊤] ⟪φ = ⊤⟫) top.intro

lemma not.fixed_point_free (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ,
have ¬φ := assume φ, contradiction[φ] ⟪φ⟫ (eq.conv[φ, ¬φ] ⟪φ = ¬φ⟫ ⟪φ⟫),
have φ := eq.conv[¬φ, φ] (eq.symm.{Prop}[φ, ¬φ] ⟪φ = ¬φ⟫) ⟪¬φ⟫,
contradiction[φ] ⟪φ⟫ ⟪¬φ⟫

/-
lemma not.fixed_point_free (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ,
have ¬φ := assume φ, contradiction ⟪φ⟫ (⟪φ = ¬φ⟫.conv ⟪φ⟫),
have φ := ⟪φ = ¬φ⟫.symm.conv ⟪¬φ⟫,
contradiction ⟪φ⟫ ⟪¬φ⟫

lemma not.no_fixpoint.{u} (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ, show ⊥, {
  let φ, ¬φ := ⟪⊥⟫.contradiction φ,
  let (¬φ) = φ, ¬φ := ⟪φ⟫.apply eq.conv[¬φ, φ],    -- yields ¬φ, which is automatically contracted with the one that comes from the contradiction tactic.
  ⟪(¬φ) = φ⟫.symmetry := ⟪φ = ¬φ⟫,
  ⟪¬φ⟫ := assume φ, show ⊥, {
     let φ, ¬φ := ⟪⊥⟫.contradiction φ,
     let φ := ⟪¬φ⟫.apply (eq.conv[φ, ¬φ] ⟪φ = ¬φ⟫),   -- φ is automatically contracted.
     ⟪φ⟫ := ⟪φ⟫
  }
}
-/

lemma exists.intro.{u} (P : u → Prop) (m : u) : P m ⇒ exists P :=
assume P m,
take (ξ : Prop),
assume ∀ x, P x ⇒ ξ,
⟪∀ x, P x ⇒ ξ⟫[m] ⟪P m⟫

lemma exists.elim.{u} (P : u → Prop) (φ : Prop) : exists P ⇒ (∀ x, P x ⇒ φ) ⇒ φ :=
assume exists P,
(change ∀ ξ, (∀ x, P x ⇒ ξ) ⇒ ξ, ⟪exists P⟫)[φ]

lemma and.elim (φ ψ ξ : Prop) : φ ∧ ψ ⇒ (φ ⇒ ψ ⇒ ξ) ⇒ ξ :=
assume φ ∧ ψ,
(change ∀ ξ, (φ ⇒ ψ ⇒ ξ) ⇒ ξ, ⟪φ ∧ ψ⟫)[ξ]

lemma and.left (φ ψ : Prop) : φ ∧ ψ ⇒ φ :=
assume φ ∧ ψ,
(and.elim[φ, ψ, φ] ⟪φ ∧ ψ⟫) (assume φ, assume ψ, ⟪φ⟫)

lemma and.right (φ ψ : Prop) : φ ∧ ψ ⇒ ψ :=
assume φ ∧ ψ,
(and.elim[φ, ψ, ψ] ⟪φ ∧ ψ⟫) (assume φ, assume ψ, ⟪ψ⟫)

lemma or.left (φ ψ : Prop) : φ ⇒ φ ∨ ψ :=
assume φ,
take (ξ : Prop),
assume φ ⇒ ξ,
assume ψ ⇒ ξ,
⟪φ ⇒ ξ⟫ ⟪φ⟫

lemma or.right (φ ψ : Prop) : ψ ⇒ φ ∨ ψ :=
assume ψ,
take (ξ : Prop),
assume φ ⇒ ξ,
assume ψ ⇒ ξ,
⟪ψ ⇒ ξ⟫ ⟪ψ⟫

lemma or.elim (φ ψ ξ : Prop) : φ ∨ ψ ⇒ (φ ⇒ ξ) ⇒ (ψ ⇒ ξ) ⇒ ξ :=
assume φ ∨ ψ,
(change ∀ ξ, (φ ⇒ ξ) ⇒ (ψ ⇒ ξ) ⇒ ξ, ⟪φ ∨ ψ⟫)[ξ]

lemma not.intro (φ : Prop) : (φ ⇒ ⊥) ⇒ ¬φ :=
assume φ ⇒ ⊥,
⟪φ ⇒ ⊥⟫

lemma not.elim (φ : Prop) : ¬φ ⇒ φ ⇒ ⊥ :=
assume ¬φ,
⟪¬φ⟫

lemma top_ne_bot (φ : Prop) : ⊤ ≠ ⊥ :=
assume ⊤ = ⊥,
eq.conv[⊤, ⊥] ⟪⊤ = ⊥⟫ top.intro

lemma eq.ap.{u, v} (m₁ m₂ : u) (f : u → v) : m₁ = m₂ ⇒ f m₁ = f m₂ :=
assume m₁ = m₂,
eq.transport.{u}[m₁, m₂, λ x, f m₁ = f x] ⟪m₁ = m₂⟫ (eq.refl.{v}[f m₁])

/-
 - Extensionality
 -/

lemma eq.congr_abs.{u, v} (m₁ m₂ : u) : (∀ (x : v), m₁ = m₂) ⇒ (λ (x : v), m₁) = (λ (x : v), m₂) :=
assume ∀ (x : v), m₁ = m₂,
fun_ext.{v, u}[(λ (x : v), m₁), (λ (x : v), m₂)] ⟪∀ (x : v), m₁ = m₂⟫

lemma eta_expand.{u, v} (f : u → v) : f = λ (x : u), f x :=
fun_ext.{u, v}[f, λ x, f x] (take (x : u), eq.refl.{v}[f x])

/-
 - functions
 -/

def injective.{u, v} (f : u → v) : Prop := ∀ x y, f x = f y ⇒ x = y
def surjective.{u, v} (f : u → v) : Prop := ∀ y, ∃ x, f x = y
