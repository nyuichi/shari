/-
 - TODO:
 - [x] stronger type inference. (propagate constraints among exprs)
 - [x] automatic insertion of forall_elim using higher-order unification
 - [ ] field access notation (ad hoc overload)
 - [ ] coersion (especially automatic insertion of rep)
 - [ ] type class
 - [x] inductive types
 - [x] inductive predicates
 - [ ] structures and instances
 - [ ] calc environment
 -/

type const Prop : Type
const imp : Prop → Prop → Prop
const forall.{u} : (u → Prop) → Prop

infixr → : 25 := imp
infix = : 50 := eq
nofix ⊤ := true
infixl ∧ : 35 := and
nofix ⊥ := false
infixl ∨ : 30 := or
prefix ¬ : 40 := not
infix ↔ : 20 := iff
infix ≠ : 50 := ne

-- A predicative version of Leibniz equality (attributed to Paulin).
-- The following set of declarations are generated.
-- (Notice that the order of arguments in eq.ind is slightly modified from [Dybjer, '97].)
--
--   const eq.{u} : u → u → Prop
--   axiom eq.refl.{u} (x : u) : x = x
--   axiom eq.ind.{u} (x : u) (y : u) (P : u → Prop) : x = y → P x → P y
--
-- This definition might look magical at first glance but is preferred to the ordinary definition by
-- least reflexive relation à la Martin-Löf because this induces a much simpler elimination rule.
inductive eq.{u} (x : u) : u → Prop
| refl : eq x

inductive true : Prop
| intro : true

inductive and (φ ψ : Prop) : Prop
| intro : φ → ψ → and

inductive false : Prop

inductive or (φ ψ : Prop) : Prop
| left : φ → or
| right : ψ → or

inductive exists.{u} (P : u → Prop) : Prop
| intro (t : u) : P t → exists

def not (φ : Prop) : Prop := φ → ⊥
def iff (φ : Prop) (ψ : Prop) : Prop := (φ → ψ) ∧ (ψ → φ)
def uexists.{u} (P : u → Prop) : Prop := ∃ x, P x ∧ (∀ y, P y → x = y)
def ne.{u} (x : u) (y : u) : Prop := ¬x = y

-- Three axioms of topos (cf. [Introduction to CATEGORY THEORY and CATEGORICAL LOGIC, T. Streicher, '03])
axiom prop_ext (φ ψ : Prop) : (φ ↔ ψ) → φ = ψ
-- The fact that this axiom holds means every topos is always internally well-pointed.
axiom fun_ext.{u, v} (f₁ f₂ : u → v) : (∀ x, f₁ x = f₂ x) → f₁ = f₂
axiom auc.{u, v} (R : u → v → Prop) : (∀ x, ∃! y, R x y) → ∃! f, ∀ x, R x (f x)

lemma eq.transport.{u} (m₁ m₂ : u) (P : u → Prop) : m₁ = m₂ → P m₁ → P m₂ := eq.ind
lemma eq.symm.{u} (m₁ m₂ : u) : m₁ = m₂ → m₂ = m₁ := assume m₁ = m₂, eq.transport ⟪m₁ = m₂⟫ @eq.refl[m₁]
lemma eq.trans.{u} (m₁ m₂ m₃ : u) : m₁ = m₂ → m₂ = m₃ → m₁ = m₃ := assume m₁ = m₂, assume m₂ = m₃, eq.transport ⟪m₂ = m₃⟫ ⟪m₁ = m₂⟫

lemma eq.ap.{u, v} (m₁ m₂ : u) (C : u → v) : m₁ = m₂ → C m₁ = C m₂ :=
assume m₁ = m₂,
eq.transport ⟪m₁ = m₂⟫ @eq.refl[C m₁]

lemma eq.congr_fun.{u, v} (f₁ f₂ : u → v) (x : u) : f₁ = f₂ → f₁ x = f₂ x :=
@eq.ap[_, _, λ (f : u → v), f x]

lemma eq.congr_arg.{u, v} (f : u → v) (x₁ x₂ : u) : x₁ = x₂ → f x₁ = f x₂ :=
eq.ap

-- TODO: remove this and replace with eq.ap
lemma eq.conv (φ ψ : Prop) : (φ = ψ) → φ → ψ := @eq.transport[_, _, λ (ξ : Prop), ξ]

-- material adequacy
lemma ma (φ : Prop) : (⊤ = φ) → φ := assume ⊤ = φ, eq.conv ⟪⊤ = φ⟫ true.intro

-- modus ponens
lemma mp (φ ψ : Prop) : φ → (φ → ψ) → ψ := assume φ, assume φ → ψ, ⟪φ → ψ⟫ ⟪φ⟫

lemma imp.trans (φ ψ ξ : Prop) : (φ → ψ) → (ψ → ξ) → φ → ξ := assume φ → ψ, assume ψ → ξ, assume φ, ⟪ψ → ξ⟫ (⟪φ → ψ⟫ ⟪φ⟫)

lemma and.left (φ ψ : Prop) : φ ∧ ψ → φ :=
assume φ ∧ ψ,
and.ind ⟪φ ∧ ψ⟫ (assume φ, assume ψ, ⟪φ⟫)

lemma and.right (φ ψ : Prop) : φ ∧ ψ → ψ :=
assume φ ∧ ψ,
and.ind ⟪φ ∧ ψ⟫ (assume φ, assume ψ, ⟪ψ⟫)

lemma not.intro (φ : Prop) : (φ → ⊥) → ¬φ :=
assume φ → ⊥,
⟪φ → ⊥⟫

lemma not.elim (φ : Prop) : ¬φ → φ → ⊥ :=
assume ¬φ,
⟪¬φ⟫

-- modus tollens
lemma mt (φ ψ : Prop) : (φ → ψ) → ¬ψ → ¬φ := imp.trans

lemma contradiction (φ : Prop) : φ → ¬φ → ⊥ := mp

lemma absurd (φ : Prop) : ⊥ → φ := false.ind

lemma not.fixed_point_free (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ,
have ¬φ := assume φ, contradiction ⟪φ⟫ (eq.conv ⟪φ = ¬φ⟫ ⟪φ⟫),
have φ := eq.conv (eq.symm ⟪φ = ¬φ⟫) ⟪¬φ⟫,
contradiction ⟪φ⟫ ⟪¬φ⟫

-- Internal version of nondegeneracy of topos.
-- Of course, this lemma holds in any (possibly degenerate) topos.
lemma true_ne_false : ⊤ ≠ ⊥ :=
assume ⊤ = ⊥,
eq.conv ⟪⊤ = ⊥⟫ true.intro

-- law of non-contradiction
lemma nc (φ : Prop) : ¬(φ ∧ ¬φ) :=
assume φ ∧ ¬φ,
contradiction (and.left ⟪φ ∧ ¬φ⟫) (and.right ⟪φ ∧ ¬φ⟫)

-- subsingleton
def unique.{u} (P : u → Prop) : Prop := ∀ (x₁ x₂ : u), P x₁ → P x₂ → x₁ = x₂

lemma uexists.intro.{u} (P : u → Prop) : exists P → unique P → uexists P :=
assume exists P,
assume unique P,
obtain (x : u), P x := ⟪exists P⟫,
exists.intro (and.intro ⟪P x⟫ (take (y : u), assume P y, ⟪unique P⟫[x, y] ⟪P x⟫ ⟪P y⟫))

lemma uexists.exists.{u} (P : u → Prop) : uexists P → exists P :=
assume uexists P,
obtain (x : u), P x ∧ ∀ (y : u), P y → x = y := ⟪uexists P⟫,
exists.intro (and.left ⟪P x ∧ ∀ y, P y → x = y⟫)

lemma uexists.unique.{u} (P : u → Prop) : uexists P → unique P :=
assume uexists P,
take (x₁ : u),
take (x₂ : u),
assume P x₁,
assume P x₂,
obtain (x : u), P x ∧ ∀ y, P y → x = y := ⟪uexists P⟫,
have ∀ y, P y → x = y := and.right ⟪P x ∧ ∀ y, P y → x = y⟫,
have x = x₁ := ⟪∀ y, P y → x = y⟫[x₁] ⟪P x₁⟫,
have x = x₂ := ⟪∀ y, P y → x = y⟫[x₂] ⟪P x₂⟫,
eq.trans (eq.symm ⟪x = x₁⟫) ⟪x = x₂⟫

lemma iff.intro (φ ψ : Prop) : (φ → ψ) → (ψ → φ) → (φ ↔ ψ) :=
assume φ → ψ,
assume ψ → φ,
and.intro ⟪φ → ψ⟫ ⟪ψ → φ⟫

lemma iff.right (φ ψ : Prop) : (φ ↔ ψ) → φ → ψ :=
assume φ ↔ ψ,
and.left ⟪φ ↔ ψ⟫

lemma iff.left (φ ψ : Prop) : (φ ↔ ψ) → ψ → φ :=
assume φ ↔ ψ,
and.right ⟪φ ↔ ψ⟫

lemma iff.trans (φ ψ ξ : Prop) : (φ ↔ ψ) → (ψ ↔ ξ) → (φ ↔ ξ) :=
assume φ ↔ ψ,
assume ψ ↔ ξ,
iff.intro
  (imp.trans (iff.right ⟪φ ↔ ψ⟫) (iff.right ⟪ψ ↔ ξ⟫))
  (imp.trans (iff.left ⟪ψ ↔ ξ⟫) (iff.left ⟪φ ↔ ψ⟫))

lemma exists.map.{u} (P Q : u → Prop) : (∀ x, P x → Q x) → (∃ x, P x) → ∃ x, Q x :=
assume ∀ x, P x → Q x,
assume ∃ x, P x,
obtain (t : u), P t := ⟪∃ x, P x⟫,
exists.intro (⟪∀ x, P x → Q x⟫[t] ⟪P t⟫)

lemma unique.map.{u} (P Q : u → Prop) : (∀ x, P x → Q x) → unique Q → unique P :=
assume ∀ x, P x → Q x,
assume unique Q,
take (x₁ : u),
take (x₂ : u),
assume P x₁,
assume P x₂,
(change ∀ x₁ x₂, Q x₁ → Q x₂ → x₁ = x₂, ⟪unique Q⟫)[x₁, x₂] (⟪∀ x, P x → Q x⟫[x₁] ⟪P x₁⟫) (⟪∀ x, P x → Q x⟫[x₂] ⟪P x₂⟫)

lemma uexists.congr.{u} (P Q : u → Prop) : (∀ x, P x ↔ Q x) → ((∃! x, P x) ↔ ∃! x, Q x) :=
assume ∀ x, P x ↔ Q x,
have ∀ x, P x → Q x := take (x : u), iff.right ⟪∀ x, P x ↔ Q x⟫[x],
have ∀ x, Q x → P x := take (x : u), iff.left ⟪∀ x, P x ↔ Q x⟫[x],
iff.intro
  (assume ∃! x, P x,
    uexists.intro
      (exists.map ⟪∀ x, P x → Q x⟫ (uexists.exists ⟪∃! x, P x⟫))
      (unique.map ⟪∀ x, Q x → P x⟫ (uexists.unique ⟪∃! x, P x⟫)))
  (assume ∃! x, Q x,
    uexists.intro
      (exists.map ⟪∀ x, Q x → P x⟫ (uexists.exists ⟪∃! x, Q x⟫))
      (unique.map ⟪∀ x, P x → Q x⟫ (uexists.unique ⟪∃! x, Q x⟫)))

/-
 - Extensionality
 -/

lemma eq.congr_abs.{u, v} (m₁ m₂ : u) : (∀ (x : v), m₁ = m₂) → (λ (x : v), m₁) = (λ (x : v), m₂) :=
assume ∀ (x : v), m₁ = m₂,
fun_ext ⟪∀ (x : v), m₁ = m₂⟫

lemma eta_expand.{u, v} (f : u → v) : f = λ x, f x :=
@fun_ext[f, λ x, f x] (take (x : u), @eq.refl[f x])

/-
 - functions
 -/

def injective.{u, v} (f : u → v) : Prop := ∀ x y, f x = f y → x = y
def surjective.{u, v} (f : u → v) : Prop := ∀ y, ∃ x, y = f x

lemma lawvere_fixpoint.{u, v} (f : v → v) : (∃ (e : u → u → v), surjective e) → ∃ y, y = f y :=
assume ∃ (e : u → u → v), surjective e,
obtain (e : u → u → v), surjective e := ⟪∃ (e : u → u → v), surjective e⟫,
obtain (x : u), (λ x, f (e x x)) = e x := ⟪surjective e⟫[λ x, f (e x x)],
have f (e x x) = e x x := eq.congr_fun ⟪(λ x, f (e x x)) = e x⟫,
exists.intro (eq.symm ⟪f (e x x) = e x x⟫)

lemma injective.unique.{u, v} (f : u → v) (y : v) : injective f → unique (λ x, y = f x) :=
assume injective f,
take (x₁ : u),
take (x₂ : u),
assume y = f x₁,
assume y = f x₂,
(change ∀ x y, f x = f y → x = y, ⟪injective f⟫)[x₁, x₂] (eq.trans (eq.symm ⟪y = f x₁⟫) ⟪y = f x₂⟫)

def split.{u, v} (f : u → v) : Prop := ∃ g, ∀ y, y = f (g y)

/-
 - sets
 -/

infix ∈ : 50 := in
infix ∉ : 50 := notin
infix ⊆ : 50 := subset
infixl ∩ : 70 := cap
infixl ∪ : 65 := cup
infix ∖ : 70 := setminus
nofix ∅ := empty

-- type set u := u → Prop

def in.{u} (x : u) (s : set u) : Prop := s x
def notin.{u} (x : u) (s : set u) : Prop := ¬(x ∈ s)
def univ.{u} : set u := λ x, ⊤
def empty.{u} : set u := λ x, ⊥
def subset.{u} (s : set u) (t : set u) : Prop := ∀ x, x ∈ s → x ∈ t
def sep.{u} (s : set u) (φ : set u) : set u := λ x, x ∈ s ∧ φ x
def cap.{u} (s : set u) (t : set u) : set u := { x | x ∈ s ∧ x ∈ t }
def cup.{u} (s : set u) (t : set u) : set u := { x | x ∈ s ∨ x ∈ t }
def bigcap.{u} (a : set (set u)) : set u := { x | ∀ s, s ∈ a → x ∈ s }
def bigcup.{u} (a : set (set u)) : set u := { x | ∃ s, s ∈ a ∧ x ∈ s }
def power.{u} (s : set u) : set (set u) := { t | t ⊆ s }
def setminus.{u} (s : set u) (t : set u) : set u := { x | x ∈ s ∧ x ∉ t }
def im.{u, v} (f : u → v) (s : set u) : set v := { y | ∃ x, x ∈ s ∧ y = f x }
def insert.{u} (a : u) (s : set u) : set u := { x | x = a ∨ x ∈ s }

lemma cantor.{u} : ¬(∃ (e : u → set u), surjective e) :=
mt lawvere_fixpoint (
  assume ∃ φ, φ = ¬φ,
  obtain (φ : Prop), φ = ¬φ := ⟪∃ φ, φ = ¬φ⟫,
  contradiction ⟪φ = ¬φ⟫ not.fixed_point_free)

def preimage.{u, v} (f : u → v) (t : set v) : set u := { x | t (f x) }

inductive fin.{u} : set u → Prop
| empty : fin empty
| insert (a : u) (s : set u) : fin s → fin (insert a s)

/-
 - well-founded
 -/

-- acc R x :↔ x is in the well-founded part of R
inductive acc.{u} (R : u → u → Prop) : u → Prop
| intro (x : u) : (∀ y, R y x → acc y) → acc x

def well_founded.{u} (R : u → u → Prop) : Prop := ∀ x, acc R x

/-
 - basic inductive types
 -/

type inductive bool
| tt : bool
| ff : bool

-- TODO
-- one may write like
--
--  type inductive prod (u v : Type) : Type
--  | mk (fst : u) (snd : v) : prod
--
type inductive prod u v
| mk : u → v → prod

type inductive unit
| star : unit

type inductive sum u v
| inl : u → sum
| inr : v → sum

type inductive empty

type inductive nat
| zero : nat
| succ : nat → nat

type inductive list u
| nil : list
| cons : u → list → list

type inductive option u
| none : option
| some : u → option

type inductive ord
| zero : ord
| succ : ord → ord
| limit : (nat → ord) → ord

type inductive bin_tree u
| empty : bin_tree
| leaf : u → bin_tree
| node : bin_tree → bin_tree → bin_tree

-- type infixr × : 35

def prod.fst.{u, v} (p : u × v) : u := prod.rec p (λ a b, a)
def prod.snd.{u, v} (p : u × v) : v := prod.rec p (λ a b, b)

def pair.{u, v} : u → v → u × v := prod.mk

type variable u v

-- TODO: use namespace
def tt : bool := bool.tt
def ff : bool := bool.ff
def fst : u × v → u := prod.fst
def snd : u × v → v := prod.snd
def star : unit := unit.star
def inl : u → sum u v := sum.inl
def inr : v → sum u v := sum.inr
def zero : nat := nat.zero
def succ : nat → nat := nat.succ
def nil : list u := list.nil
def cons : u → list u → list u := list.cons
def none : option u := option.none
def some : u → option u := option.some

lemma unit.eta_expand (x : unit) : x = star :=
unit.ind eq.refl

lemma unit.eta_reduce (x : unit) : star = x :=
eq.symm unit.eta_expand

lemma unit_ext (x₁ x₂ : unit) : x₁ = x₂ :=
eq.trans unit.eta_expand unit.eta_reduce

lemma prod.beta.{u, v} (x : u) (y : v) : x = fst (prod.mk x y) ∧ y = snd (prod.mk x y) :=
and.intro eq.refl eq.refl

/- FIXME
lemma prod_ext.{u, v} (p₁ p₂ : u × v) : fst p₁ = fst p₂ → snd p₁ = snd p₂ → p₁ = p₂ :=
prod.ind
  take (a₁ : u), take (b₁ : v),
  prod.ind
  take (a₂ : u), take (b₂ : v),
    assume fst ⟨a₁, b₁⟩ = fst ⟨a₂, b₂⟩,
    assume snd ⟨a₁, b₁⟩ = snd ⟨a₂, b₂⟩,
    have a₁ = a₂ :=
      have a₁ = fst ⟨a₁, b₁⟩ := eq.refl,
      have fst ⟨a₂, b₂⟩ = a₂ := eq.refl,
      eq.trans ⟪a₁ = fst ⟨a₁, b₁⟩⟫ (eq.trans ⟪fst ⟨a₁, b₁⟩ = fst ⟨a₂, b₂⟩⟫ ⟪fst ⟨a₂, b₂⟩ = a₂⟫),
    have b₁ = b₂ :=
      have b₁ = snd ⟨a₁, b₁⟩ := eq.refl,
      have snd ⟨a₂, b₂⟩ = b₂ := eq.refl,
      eq.trans ⟪b₁ = snd ⟨a₁, b₁⟩⟫ (eq.trans ⟪snd ⟨a₁, b₁⟩ = snd ⟨a₂, b₂⟩⟫ ⟪snd ⟨a₂, b₂⟩ = b₂⟫),
    have ⟨a₁, b₁⟩ = ⟨a₂, b₁⟩ := eq.ap ⟪a₁ = a₂⟫,
    have ⟨a₂, b₁⟩ = ⟨a₂, b₂⟩ := eq.ap ⟪b₁ = b₂⟫,
    eq.trans ⟪⟨a₁, b₁⟩ = ⟨a₂, b₁⟩⟫ ⟪⟨a₂, b₁⟩ = ⟨a₂, b₂⟩⟫

lemma prod.eta.{u, v} (p : prod u v) : p = prod.mk (fst p) (snd p) :=
prod_ext eq.refl eq.refl
-/

lemma bool.case (b : bool) : b = tt ∨ b = ff :=
bool.ind (or.left eq.refl) (or.right eq.refl)

lemma bool.tt_ne_ff : tt ≠ ff :=
assume tt = ff,
have ⊤ = ⊥ :=
  have ⊤ = bool.rec tt ⊤ ⊥ := eq.refl,
  have bool.rec tt ⊤ ⊥ = bool.rec ff ⊤ ⊥ := @eq.ap[_, _, λ b, bool.rec b ⊤ ⊥] ⟪tt = ff⟫,
  have bool.rec ff ⊤ ⊥ = ⊥ := eq.refl,
  eq.trans ⟪⊤ = bool.rec tt ⊤ ⊥⟫ (eq.trans ⟪bool.rec tt ⊤ ⊥ = bool.rec ff ⊤ ⊥⟫ ⟪bool.rec ff ⊤ ⊥ = ⊥⟫),
contradiction ⟪⊤ = ⊥⟫ true_ne_false

/-
 - choice
 -/

-- The type of inhabited subsets.
-- The command is desugared into the following set of declarations.
--
--   type const inhab : Type → Type
--   const inhab.rep.{u} : inhab u → set u
--   axiom inhab.inhabited.{u} (d : inhab u) : ∃ x, x ∈ inhab.rep d
--   axiom inhab.abs.{u} (s : set u) : (∃ x, x ∈ s) → ∃ d, s = inhab.rep d
--   axiom inhab.ext.{u} (d₁ d₂ : inhab u) : inhab.rep d₁ = inhab.rep d₂ → d₁ = d₂
--
structure inhab u := {
  const rep : set u
  axiom inhabited : ∃ x, x ∈ rep
}

lemma inhab.uabs.{u} (s : set u) : (∃ x, x ∈ s) → ∃! c, s = inhab.rep c :=
assume ∃ x, x ∈ s,
obtain (c : inhab u), s = inhab.rep c := inhab.abs ⟪∃ x, x ∈ s⟫,
uexists.intro
  ⟪s = inhab.rep c⟫
  (take (s₁ : inhab v),
   take (s₂ : inhab v),
   assume s = inhab.rep s₁,
   assume s = inhab.rep s₂,
   have inhab.rep s₁ = inhab.rep s₂ := eq.trans (eq.symm ⟪s = inhab.rep s₁⟫) ⟪s = inhab.rep s₂⟫,
   inhab.ext ⟪inhab.rep s₁ = inhab.rep s₂⟫)

-- The exisistence of the constant and the axiom state that every type u is a choice type.
const choice.{u} : inhab u → u
axiom choice.spec.{u} (x : inhab u) : choice x ∈ inhab.rep x

lemma ac.{u, v} (R : u → v → Prop) : (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) :=
assume ∀ x, ∃ y, R x y,
have ∀ x, ∃! (h : inhab v), R x = inhab.rep h :=
  take (x : u),
  @inhab.uabs[R x] ⟪∀ x, ∃ y, R x y⟫[x],
have ∃! (f : u → inhab v), ∀ x, R x = inhab.rep (f x) :=
  auc ⟪∀ x, ∃! (h : inhab v), R x = inhab.rep h⟫,
obtain (f : u → inhab v), ∀ x, R x = inhab.rep (f x) :=
  uexists.exists ⟪∃! (f : u → inhab v), ∀ x, R x = inhab.rep (f x)⟫,
exists.intro
  (take (x : u),
   have inhab.rep (f x) (choice (f x)) :=
     choice.spec,
   eq.conv (eq.symm (eq.congr_fun ⟪∀ x, R x = inhab.rep (f x)⟫[x])) ⟪inhab.rep (f x) (choice (f x))⟫)

lemma surjective.split.{u, v} (f : u → v) : surjective f → split f :=
ac

-- Diaconescu's argument: ac + prop_ext + fun_ext → em
--
-- The bool type having a choice function is in fact equivalent to em.
-- While em implies (using prop_ext) Prop is _internally two-valued_ i.e.
-- ∀ φ, φ = ⊤ ∨ φ = ⊥, the ambient topos may not be (externally) two-valued;
-- it only implies the topos is boolean.
lemma em (φ : Prop) : φ ∨ ¬φ :=
have ∃ b, φ ∨ b = tt := exists.intro (or.right eq.refl),
have ∃ b, φ ∨ b = ff := exists.intro (or.right eq.refl),
obtain (h₁ : inhab bool), (λ b, φ ∨ b = tt) = inhab.rep h₁ := inhab.abs ⟪∃ b, φ ∨ b = tt⟫,
obtain (h₂ : inhab bool), (λ b, φ ∨ b = ff) = inhab.rep h₂ := inhab.abs ⟪∃ b, φ ∨ b = ff⟫,
have φ → choice h₁ = choice h₂ :=
  assume φ,
  have (λ b, φ ∨ b = tt) = (λ b, φ ∨ b = ff) := fun_ext (
    take (b : bool),
    have φ ∨ b = tt := or.left ⟪φ⟫,
    have φ ∨ b = ff := or.left ⟪φ⟫,
    prop_ext (iff.intro (assume φ ∨ b = tt, ⟪φ ∨ b = ff⟫) (assume φ ∨ b = ff, ⟪φ ∨ b = tt⟫))
  ),
  have inhab.rep h₁ = inhab.rep h₂ :=
    eq.trans (eq.symm ⟪(λ b, φ ∨ b = tt) = inhab.rep h₁⟫) (eq.trans ⟪(λ b, φ ∨ b = tt) = (λ b, φ ∨ b = ff)⟫ ⟪(λ b, φ ∨ b = ff) = inhab.rep h₂⟫),
  have h₁ = h₂ :=
    inhab_ext ⟪inhab.rep h₁ = inhab.rep h₂⟫,
  eq.congr_arg ⟪h₁ = h₂⟫,
have φ ∨ choice h₁ = tt :=
  eq.conv (eq.symm (eq.congr_fun ⟪(λ b, φ ∨ b = tt) = inhab.rep h₁⟫)) choice.spec,
have φ ∨ choice h₂ = ff :=
  eq.conv (eq.symm (eq.congr_fun ⟪(λ b, φ ∨ b = ff) = inhab.rep h₂⟫)) choice.spec,
have φ ∨ choice h₁ ≠ choice h₂ :=
  or.ind ⟪φ ∨ choice h₁ = tt⟫
    (assume φ, or.left ⟪φ⟫)
    (assume choice h₁ = tt,
      or.ind ⟪φ ∨ choice h₂ = ff⟫
        (assume φ, or.left ⟪φ⟫)
        (assume choice h₂ = ff,
          or.right (eq.transport (eq.symm ⟪choice h₂ = ff⟫) (eq.transport (eq.symm ⟪choice h₁ = tt⟫) bool.tt_ne_ff)))),
or.ind ⟪φ ∨ choice h₁ ≠ choice h₂⟫
  (assume φ,
    or.left ⟪φ⟫)
  (assume choice h₁ ≠ choice h₂,
    or.right (mt ⟪φ → choice h₁ = choice h₂⟫ ⟪choice h₁ ≠ choice h₂⟫))

/-
 - support
 -/

-- A type operator sending an inhabited type to its propositional truncation.
-- This type has several names in the literature, such as support type, bracket type, or propositional truncation.
structure is_inhabited u := {
  axiom inhabited : ∃ (a : u), ⊤
}

axiom is_inhabited_ext.{u} (h₁ h₂ : is_inhabited u) : h₁ = h₂

instance is_inhabited.mk.{u} (x : u) : is_inhabited u := {
  lemma inhabited := exists.intro true.intro
}

instance is_inhabited.join.{u} (h : is_inhabited (is_inhabited u)) : is_inhabited u := {
  lemma inhabited : ∃ (a : is_inhabited u), ⊤ := @is_inhabited.inhabited[h]
}

-- internal global choice operator
-- 
-- Introducing this constant restricts the class of models to toposes whose supports split.
-- Note we do not have an object-level function assigning for each type u the choice function,
-- which would imply axiom of choice.
-- In the presence of dependent products, this operator corresponds to the law of double negation:
--
--   is_inhabited u ≅ Π (p : Prop), (u → El(p)) → El(p)
--
-- where we assume Prop is a Tarski universe.
--
-- One can interpret this function in Kripke-Joyal semantics as follows:
-- whenever one proves ⊢ ∃ (x : u), ⊤, hence ⊩ ∃ (x : u), ⊤, which in general
-- means there exist an object V, V → 1 epi and V → u, one can safely assume V was 1.
const epsilon.{u} : is_inhabited u → u

/-
 - natural numbers
 -/

infixl + : 65 := add
infixl - : 65 := sub
infixl * : 70 := mul
infixl / : 70 := div
prefix - : 100 := neg
infixr ^ : 80 := pow
infix ≤ : 50 := le
infix < : 50 := lt
infix ≥ : 50 := ge
infix > : 50 := gt

def add (n m : ℕ) : ℕ := rec n m succ
def mul (n m : ℕ) : ℕ := rec n zero (add m)

def bit0 (n : ℕ) : ℕ := n + n
def bit1 (n : ℕ) : ℕ := succ (bit0 n)

/-
 - (some) algebras
 -/

structure monoid u := {
  const mult : u → u → u
  const unit : u
  axiom assoc (x₁ x₂ x₃ : u) : mult (mult x₁ x₂) x₃ = mult x₁ (mult x₂ x₃)
  axiom left_unit (x : u) : mult unit x = x
  axiom right_unit (x : u) : mult x unit = x
}

instance Prop_conj_monoid : monoid Prop := {
  def mult := and
  def unit := ⊤
  lemma assoc := and.assoc
  lemma left_unit := true_and
  lemma right_unit := and_true
}

instance Prop_disj_monoid : monoid Prop := {
  def mult := or
  def unit := ⊥
  lemma assoc := or.assoc
  lemma left_unit := false_or
  lemma right_unit := or_false
}

instance power_monoid.{u, v} (m : monoid u) : monoid (v → u) := {
  def mult (f g : v → u) := λ x, mult m (f x) (g x)
  def unit := λ x, unit m
  lemma assoc := sorry
  lemma left_unit := sorry
  lemma right_unit := sorry
}

structure pointed u := {
  const pt : u
}

structure is_prop u := {
  axiom spec (x₁ x₂ : u) : x₁ = x₂
}

structure C := {
  const x : u
  axiom spec : P x
}

def rep := C.x
lemma rep.char := C.spec

axiom C.abs : ∀ x, spec x → (∃ c, x = rep c)

axiom C.ind (P : C → Prop) (c : C) : (∀ x, spec x → (∃! c, x = rep c) → ∃ c, x = rep c ∧ P c) → P c

(∀ x, spec x → ∃ c, x = rep c ∧ P c) → P c₁

structure comprehension base u := {
  -- the characteristic
  const char : base → Prop

  const rep : u → base

  -- NB: `char (rep x) = ⊤` is stronger thant `char (rep x)` (without prop_ext). Should we use that?
  axiom rep.char (x : u) : char (rep x)

  -- this alone is insufficient as this only asserts the (unique) existence but does not give the concrete term.
  axiom char.abs (y : base) : char y → ∃! x, y = rep x
}

lemma rep.injective.{base, u} (d : comprehension base u) : injective (rep d) :=
take (x₁ : u),
take (x₂ : u),
(uexists.unique (char.abs rep.char))[_, _] eq.refl

-- structure group u :=
-- (mul : u → u → u)
-- (one : u)
-- (inv : u → u)
-- (assume assoc : ∀ x₁ x₂ x₃, mul (mul x₁ x₂) x₃ = mul x₁ (mul x₂ x₃))
-- (assume left_unit : ∀ x, mul one x = x)
-- (assume right_unit : ∀ x, mul x one = x)
-- (assume left_inv : ∀ x, mul (inv x) x = one)
-- (assume right_inv : ∀ x, mul x (inv x) = one)

type const monoid : Type → Type
const mult.{u} : monoid u → u → u → u
const unit.{u} : monoid u → u
axiom assoc.{u} (m : monoid u) (x₁ x₂ x₃ : u) : mult m (mult m x₁ x₂) x₃ = mult m x₁ (mult m x₂ x₃)
axiom left_unit.{u} (m : monoid u) (x : u) : mult m (unit m) x = x
axiom right_unit.{u} (m : monoid u) (x : u) : mult m x (unit m) = x

type variable u

def interchange (m₁ m₂ : monoid u) : Prop := ∀ a b c d, mult m₁ (mult m₂ a b) (mult m₂ c d) = mult m₂ (mult m₁ a c) (mult m₁ b d)

/-
lemma interchange.units_are_equal (m₁ m₂ : monoid u) : interchange m₁ m₂ → unit m₁ = mult m₂ (mult m₁ (unit m₁) (unit m₂)) (mult m₁ (unit m₂) (unit m₁)) :=
assume interchange m₁ m₂,
have unit m₁ = mult m₁ (unit m₁) (unit m₁) := eq.symm left_unit,
have mult m₁ (unit m₁) (unit m₁) = mult m₁ (mult m₂ (unit m₁) (unit m₂)) (unit m₁) := @eq.ap[_, _, λ x, mult m₁ x (unit m₁)] (eq.symm @right_unit[m₂, unit m₁]),
have mult m₁ (mult m₂ (unit m₁) (unit m₂)) (unit m₁) = mult m₁ (mult m₂ (unit m₁) (unit m₂)) (mult m₂ (unit m₂) (unit m₁)) := @eq.ap[_, _, λ x, mult m₁ (mult m₂ (unit m₁) (unit m₂)) x] (eq.symm left_unit),
have mult m₁ (mult m₂ (unit m₁) (unit m₂)) (mult m₂ (unit m₂) (unit m₁)) = mult m₂ (mult m₁ (unit m₁) (unit m₂)) (mult m₁ (unit m₂) (unit m₁)) := ⟪interchange m₁ m₂⟫[unit m₁, unit m₂, unit m₂, unit m₁],
eq.trans
  ⟪unit m₁ = mult m₁ (unit m₁) (unit m₁)⟫
  (eq.trans
    ⟪mult m₁ (unit m₁) (unit m₁) = mult m₁ (mult m₂ (unit m₁) (unit m₂)) (unit m₁)⟫
    (eq.trans
      ⟪mult m₁ (mult m₂ (unit m₁) (unit m₂)) (unit m₁) = mult m₁ (mult m₂ (unit m₁) (unit m₂)) (mult m₂ (unit m₂) (unit m₁))⟫)
      ⟪mult m₁ (mult m₂ (unit m₁) (unit m₂)) (mult m₂ (unit m₂) (unit m₁)) = mult m₂ (mult m₁ (unit m₁) (unit m₂)) (mult m₁ (unit m₂) (unit m₁))⟫)
-- have unit m₁ = mult m₂ (unit m₂) (mult m₁ (unit m₂) (unit m₁)) := eq.trans ⟪unit m₁ = mult m₂ (mult m₁ (unit m₁) (unit m₂)) (mult m₁ (unit m₂) (unit m₁))⟫ (eq.ap left_unit),
-- have unit m₁ = mult m₂ (unit m₂) (unit m₂) := eq.trans ⟪unit m₁ = mult m₂ (unit m₂) (mult m₁ (unit m₂) (unit m₁))⟫ (eq.ap right_unit),
-- have unit m₁ = unit m₂ := eq.trans ⟪unit m₁ = mult m₂ (unit m₂) (unit m₂)⟫ left_unit,
-- ⟪unit m₁ = unit m₂⟫
-/

type const group : Type → Type
const group.monoid.{u} : group u → monoid u
const inv.{u} : group u → u → u
axiom left_inv.{u} (g : group u) (x : u) : mult (group.monoid g) (inv g x) x = unit (group.monoid g)
axiom right_inv.{u} (g : group u) (x : u) : mult (group.monoid g) x (inv g x) = unit (group.monoid g)



const abs.{P, u, a} : is_predicate P u → is_singleton u a → apply u P a → comprehension u P

structure is_comprehension base u := {
  const char : base → Prop
  const rep : u → base
  axiom ext : ∀ x₁ x₂, rep x₁ = rep x₂ → x₁ = x₂
  axiom spec : ∀ m, char (rep m)
  axiom abs : ∀ x, char x → ∃ m, x = rep m
}

structure is_singleton u a := {
  const is_comprehension : is_comprehension u a
  const pt : a
  axiom is_contractible : ∀ x, x = pt
}

structure is_predicate u P := {
  const is_singleton : is_singleton (u → Prop) P
}

structure apply u P x := {
  const P_is_predicate : is_predicate u P
  const a_is_singleton : is_singleton u a
  axiom spec : rep (pt P_is_predicate) (rep (pt a_is_singleton))
}

structure comprehension u P := {

}

1 ⊨ ∀ y, P y → ∃ x, y = rep x
===================================
for any a : U → Y, U ⊨ P a → ∃ x, a = rep x
===============================
for any a : U → Y, h : V → U, (V ⊨ P (a h)) ⇒ (V ⊨ ∃ x, (a h) = rep x)
====================
for any b : V → Y, (V ⊨ P b) ⇒ (V ⊨ ∃ x, b = rep x)
===========
for any b : V → Y, (V ⊨ P b) ⇒ (∃ f : W → V epi, s : W → X, W ⊨ (b f) = rep s)
===========
for any b : V → Y, (V ⊨ P b) ⇒ (∃ f : W → V epi, s : W → X, b f = rep s)

    s
W -----> X
|        v
v f      | rep
v        v
V -----> Y
    b
