/-
 - TODO:
 - [x] stronger type inference. (propagate constraints among exprs)
 - [x] automatic insertion of forall_elim using higher-order unification
 - [x] inductive types
 - [x] inductive predicates
 - [x] structures and instances
 - [x] type class
 - [x] calc environment
 - [ ] improved error reporting
 - [ ] coercion
 - [ ] namespace
 - [ ] let expr
 - [ ] local typedef
 - [ ] kernel support for eta equality of lambdas
 -/

-- TODO: structure.rec -> field projections
-- TODO: remove structure.ext

/-

** FOR PLAYGROUND USERS **

You can type unicode characters with typing `\` + command names. Commands mostly follow the naming conventions of LaTeX.
See the comprehensive list of input commands [here](./unicode-map.js).


# Syntax

Proof expressions include the following:

take (x : τ), e               forall introduction
e[m₁, ⋯, mₙ]                  forall elimination (Note that invocation of a proved or postulated fact implicitly inserts forall eliminations.)
assume φ, e                   imp introduction
e₁ e₁                         imp elimination
change φ, e                   change the goal to a definitional equivalent
( e ), { e }                  grouping. no distinction between a pair of parentheses and of braces.
have φ := e₁, e₂
obtain (x : τ), φ := e₁, e₂
calc m₁ = m₂ := e₁ ... = m₃ := e₂ ... = m₄ := e₃


# The logical foundation

Some axioms / constants are postulated upon the base logic.
Their consistency is established from semantic arguments.

| logic                                              | models                                      |
|----------------------------------------------------|---------------------------------------------|
| intuitionistic higher-order logic (the base logic) | any model of PTS λHOL                       |
| + fun_ext + prop_ext + auc                         | any topos                                   |
|   (+ structures/instances + definite_description)  |   (whose morphisms 1-1 correspond to terms) |
|   + ac                                             |   satisfying internal axiom of choice       |
|   + indefinite_description                         |   in which supports split                   |
|   + inductive types                                |   with NNO                                  |

(For those who are familiar with topos theory:
the model of our logic is almost the same as Lawvere's Elementary Theory of the Category of Sets (ETCS).
If we assume that the ambient topos is moreover two-valued (that is, it satisfies the _external_ law of
excluded middle), then it is precisely an ETCS. Nonetheless, two-valuedness is not required for this logic, since
it is an external property. Inside the logic, one cannot distinguish whether the model is two-valued or not.
In fact, two-valuedness implies nondegeneracy of the topos.)

The base logic is described by the following pure type system (PTS):

| S | Prop, Type, Kind |
| A | Prop : Type, Type : Kind |
| R | (Prop, Prop), (Type, Type), (Type, Prop) |

`φ ψ ⋯ : Prop` are called _propositions_.
`e₁ e₂ ⋯ : φ` are called _(proof) expressions_.

-/

-- the very basic building blocks of our logic
type const Prop : Type
const imp : Prop → Prop → Prop
-- the universe Prop of all propositions is impredicative.
const forall.{u} : (u → Prop) → Prop

infixr → : 25 := imp
infix = : 50 := eq
nofix ⊤ := has_top.top
infixl ∧ : 35 := has_wedge.wedge
nofix ⊥ := has_bot.bot
infixl ∨ : 30 := has_vee.vee
prefix ¬ : 40 := has_neg.neg
infix ↔ : 20 := iff
infix ≠ : 50 := ne

infixl + : 65 := has_plus.plus
infixl - : 65 := sub
infixl * : 70 := has_ast.ast
infixl / : 70 := div
prefix - : 100 := neg
infixr ^ : 80 := pow
infix ≤ : 50 := has_le.le
infix < : 50 := has_le.lt
infix ≥ : 50 := has_le.ge
infix > : 50 := has_le.gt

-- The kernel and higher-order unifier recognize three reduction rules as the definitional equivalence:
--
-- 1. β-reduction: (λ x, M) N ↦ [N/x]M
-- 2. δ-reduction: c ↦ M  where there is a definition somewhere `def c := M`.
-- 3. κ-reduction: c ↦ N  where c is a method from a class `C u₁ ⋯ uₙ` and c is assigned types so that
--                              it is resolved to some concrete instance.
--
-- Rules 1 and 2 are type agnostic. Also, rule 3 can be applied to partially typed terms as long as its method
-- can be resolved to a concrete term.
--
-- There are basically two approaches to incorporate type classes into a language.
--
-- a) Add support for implicit arguments and build type classes on it.
-- b) Add them natively.
--
-- (a) is taken by most languages supporting dependent types including Coq, Agda, Lean, and Scala.
-- Others such as Haskell and Isabelle use (b). Our choice is (b), because we do not have dependency thus
-- implicit arguments are not necessary in typing, and using (b) makes it easier to force the coherency of instances.
-- (While languages using (a) allow overlapping instances and non-deterministic elaboration, coherency is still
-- important to avoid unintentional behaviours. In fact, in Lean, programmers must be careful not to introduce
-- _morally incoherent_ instances.)
--
-- Because neither our kernel nor the unifier implements ι-reduction, we implement class method instantiation by a special
-- equality rule called κ-reduction. When the elaborator encounters a κ-redex, it eagerly reduces, so we recommend using
-- as small terms as possible in instance method definitions to avoid exponential blow-up.
--
-- Although class instantiations are not lowered to terms representing structure objects, the kernel implicitly generates
-- instance objects that are invisible in the language surface. This design allows us to easily prove the consistency of the logic,
-- otherwise it is very error-prone [Kunˇcar & Popescu, '19].

-- This introduces:
-- 
-- 1. A class predicate `has_top` with one variable. Class predicates have a separate namespace.
-- 2. A constant with a class constraint: `const top.{u} [has_top u] : u`.
--    If there is an instance `I` of class `has_top τ`, top.{τ} is κ-reducible to I.top.
--
class structure has_top u := {
  const top : u
}

class structure has_bot u := {
  const bot : u
}

class structure has_wedge u := {
  const wedge : u → u → u
}

class structure has_vee u := {
  const vee : u → u → u
}

class structure has_neg u := {
  const neg : u → u
}

class structure has_plus u := {
  const plus : u → u → u
}

class structure has_ast u := {
  const ast : u → u → u
}

class structure has_le u := {
  const le : u → u → Prop
}

-- The most generic class.
-- One can use only this class to emulate every class structure.
class structure has u := {
  const summon : u
}

def summon.{u} [has u] : u := has.summon

-- The unifier uses this class to resolve unconstrained metavariables.
class structure default u := {
  const value : u
}

/-

Inductive predicate families (a la Dybjer)

Inductive predicate families can be built in any models of (intuitionistic) higher-order logic
with impredicative universe of propositions. We could define inductive predicate families in
terms of impredicative encoding of logical connectives and μ operator.

  -- Leibniz equality
  def eq.{u} (x y : u) : Prop := ∀ P, P x → P y
  def top : Prop := ∀ P, P → P
  def and (φ ψ : Prop) : Prop := ∀ P, (φ → ψ → P) → P
  -- Russell-Prawitz encoding
  def bot : Prop := ∀ P, P
  def or (φ ψ : Prop) : Prop := ∀ P : Prop, (φ → P) → (ψ → P) → P
  def exists.{u} (P : u → Prop) : Prop := ∀ Q, (∀ x, P x → Q) → Q
  -- ⋂ { P | F P ⊆ P }
  def mu.{u} (F : (u → Prop) → (u → Prop)) : u → Prop := λ x, ∀ P, (∀ y, F P y → P y) → P x

  def unique.{u} (P : u → Prop) : Prop := ∃ (x : u), P x ∧ (∀ y, P y → x = y)

We can easily check that these definitions satisfy the expected properties.
Note also that the μ operator only gives the least fixedpoint of monotone operators up to predicate equivalence.
In the presence of fun_ext and prop_ext, we can prove that the least fixedpoint is unique up to equality.
See e.g. [Some flavours of topos theory, F. Borceux, '22] for the Knaster-Tarski fixedpoint theorem in topos.
On top of these building blocks, we can uniformly define inductive predicates.
For example, the reflexive transitive closure of a binary relation R is defined as follows.

  def reachable.{u} (R : u → u → Prop) (x : u) : u → Prop := mu (λ P, λ z, (x = z) ∨ ∃ y, P y ∧ R y z)

Compare this with the following direct definition of reachable as an inductive family.

  inductive reachable.{u} (R : u → u → Prop) (x : u) : u → Prop
  | base : reachable x
  | step (y z : u) : reachable y → R y z → reachable z

Impredicative higher-order logic has not only μ operator but also ν operator (greatest fixedpoint).

  def nu.{u} (F : (u → Prop) → (u → Prop)) : u → Prop := λ x, ∀ P, (∀ y, P y → F P y) → P x

While we can define coinductive predicates using ν operator, we currently do not support coinductive
predicates natively.
-/

-- A predicative version of Leibniz equality (attributed to Paulin).
-- The following set of declarations are generated.
-- (Notice that the order of arguments in eq.ind is slightly modified from [Dybjer, '97].)
--
--   const eq.{u} : u → u → Prop
--   axiom eq.refl.{u} (x : u) : x = x
--   axiom eq.ind.{u} (x : u) (y : u) (P : u → Prop) : x = y → P x → P y
--
-- This definition might look magical at first glance but is preferred to the ordinary definition by
-- least reflexive relation à la Martin-Löf because this induces a much simpler elimination rule.
--
inductive eq.{u} (x : u) : u → Prop
| refl : eq x

inductive true : Prop
| intro : true

inductive false : Prop

inductive and (φ ψ : Prop) : Prop
| intro : φ → ψ → and

inductive or (φ ψ : Prop) : Prop
| left : φ → or
| right : ψ → or

inductive exists.{u} (P : u → Prop) : Prop
| intro (t : u) : P t → exists

class instance Prop.has_top : has_top Prop := {
  def top : Prop := true
}

class instance Prop.has_bot : has_bot Prop := {
  def bot : Prop := false
}

class instance Prop.has_wedge : has_wedge Prop := {
  def wedge : Prop → Prop → Prop := and
}

class instance Prop.has_vee : has_vee Prop := {
  def vee : Prop → Prop → Prop := or
}

def not (φ : Prop) : Prop := φ → ⊥

class instance Prop.has_neg : has_neg Prop := {
  def neg : Prop → Prop := not
}

class instance Prop.default : default Prop := {
  def value : Prop := ⊤
}

def iff (φ : Prop) (ψ : Prop) : Prop := (φ → ψ) ∧ (ψ → φ)
def uexists.{u} (P : u → Prop) : Prop := ∃ x, P x ∧ (∀ y, P y → x = y)
def ne.{u} (x : u) (y : u) : Prop := ¬x = y

def has_le.lt.{u} [has_le u] (x y : u) : Prop := x ≤ y ∧ x ≠ y
def has_le.ge.{u} [has_le u] (x y : u) : Prop := y ≤ x
def has_le.gt.{u} [has_le u] (x y : u) : Prop := y < x

infix ≃ : 20 := has_simeq.simeq

class structure has_simeq u := {
  const simeq : u → u → Prop
}

class instance Prop.has_simeq : has_simeq Prop := {
  def simeq : Prop → Prop → Prop := iff
}

class instance fun.has_simeq.{u, v} : has_simeq (u → v) := {
  def simeq (f g : u → v) : Prop := ∀ x, f x = g x
}

-- Three axioms of topos (cf. [Introduction to CATEGORY THEORY and CATEGORICAL LOGIC, T. Streicher, '03])
-- 1. Propositional extensionality
axiom prop_ext (φ ψ : Prop) : (φ ≃ ψ) → φ = ψ
-- 2. Functional extensionality (``internal well-pointedness'')
axiom fun_ext.{u, v} (f₁ f₂ : u → v) : (f₁ ≃ f₂) → f₁ = f₂
-- 3. Axiom of unique choice
axiom auc.{u, v} (R : u → v → Prop) : (∀ x, ∃! y, R x y) → ∃! f, ∀ x, R x (f x)

lemma eq.transport.{u} (m₁ m₂ : u) (P : u → Prop) : m₁ = m₂ → P m₁ → P m₂ := eq.ind
lemma eq.symm.{u} (m₁ m₂ : u) : m₁ = m₂ → m₂ = m₁ := assume m₁ = m₂, eq.transport «m₁ = m₂» eq.refl
lemma eq.trans.{u} (m₁ m₂ m₃ : u) : m₁ = m₂ → m₂ = m₃ → m₁ = m₃ := assume m₁ = m₂, assume m₂ = m₃, eq.transport «m₂ = m₃» «m₁ = m₂»

lemma eq.ap.{u, v} (m₁ m₂ : u) (C : u → v) : m₁ = m₂ → C m₁ = C m₂ :=
assume m₁ = m₂,
eq.transport «m₁ = m₂» eq.refl

lemma eq.congr_fun.{u, v} (f₁ f₂ : u → v) (x : u) : f₁ = f₂ → f₁ x = f₂ x :=
eq.ap

lemma eq.congr_arg.{u, v} (f : u → v) (x₁ x₂ : u) : x₁ = x₂ → f x₁ = f x₂ :=
eq.ap

-- material adequacy
lemma ma (φ : Prop) : (⊤ = φ) → φ := assume ⊤ = φ, eq.transport «⊤ = φ» true.intro

-- modus ponens
lemma mp (φ ψ : Prop) : φ → (φ → ψ) → ψ := assume φ, assume φ → ψ, «φ → ψ» «φ»

lemma imp.trans (φ ψ ξ : Prop) : (φ → ψ) → (ψ → ξ) → φ → ξ := assume φ → ψ, assume ψ → ξ, assume φ, «ψ → ξ» («φ → ψ» «φ»)

lemma and.left (φ ψ : Prop) : φ ∧ ψ → φ :=
assume φ ∧ ψ,
and.ind «φ ∧ ψ» (assume φ, assume ψ, «φ»)

lemma and.right (φ ψ : Prop) : φ ∧ ψ → ψ :=
assume φ ∧ ψ,
and.ind «φ ∧ ψ» (assume φ, assume ψ, «ψ»)

lemma not.intro (φ : Prop) : (φ → ⊥) → ¬φ :=
assume φ → ⊥,
«φ → ⊥»

lemma not.elim (φ : Prop) : ¬φ → φ → ⊥ :=
assume ¬φ,
«¬φ»

-- modus tollens
lemma mt (φ ψ : Prop) : (φ → ψ) → ¬ψ → ¬φ := imp.trans

lemma contradiction (φ : Prop) : φ → ¬φ → ⊥ := mp

lemma absurd (φ : Prop) : ⊥ → φ := false.ind

lemma not.fixed_point_free (φ : Prop) : φ ≠ ¬φ :=
assume φ = ¬φ,
have ¬φ := assume φ, contradiction «φ» (eq.transport «φ = ¬φ» «φ»),
have φ := eq.transport (eq.symm «φ = ¬φ») «¬φ»,
contradiction «φ» «¬φ»

-- Internal version of nondegeneracy of topos.
-- Of course, this lemma holds in any (possibly degenerate) topos.
lemma true_ne_false : true ≠ false :=
assume true = false,
eq.transport «true = false» true.intro

-- law of non-contradiction
lemma nc (φ : Prop) : ¬(φ ∧ ¬φ) :=
assume φ ∧ ¬φ,
contradiction (and.left «φ ∧ ¬φ») (and.right «φ ∧ ¬φ»)

-- subsingleton
def unique.{u} (P : u → Prop) : Prop := ∀ (x₁ x₂ : u), P x₁ → P x₂ → x₁ = x₂

lemma uexists.intro.{u} (P : u → Prop) : exists P → unique P → uexists P :=
assume exists P,
assume unique P,
-- TODO: fix this bug or make the kernel to recognize eta equality of lambdas.
-- obtain (x : u), P x := «exists P»,
-- exists.intro (and.intro «P x» (take (y : u), assume P y, «unique P»[x, y] «P x» «P y»))
@exists.ind[P, _] «exists P» (take (x : u), assume P x,
exists.intro (and.intro «P x» (take (y : u), assume P y, «unique P»[x, y] «P x» «P y»))
)

lemma uexists.exists.{u} (P : u → Prop) : uexists P → exists P :=
assume uexists P,
obtain (x : u), P x ∧ ∀ (y : u), P y → x = y := «uexists P»,
exists.intro (and.left «P x ∧ ∀ y, P y → x = y»)

lemma uexists.unique.{u} (P : u → Prop) : uexists P → unique P :=
assume uexists P,
take (x₁ : u),
take (x₂ : u),
assume P x₁,
assume P x₂,
obtain (x : u), P x ∧ ∀ y, P y → x = y := «uexists P»,
have ∀ y, P y → x = y := and.right «P x ∧ ∀ y, P y → x = y»,
have x = x₁ := «∀ y, P y → x = y»[x₁] «P x₁»,
have x = x₂ := «∀ y, P y → x = y»[x₂] «P x₂»,
eq.trans (eq.symm «x = x₁») «x = x₂»

lemma iff.intro (φ ψ : Prop) : (φ → ψ) → (ψ → φ) → (φ ↔ ψ) :=
assume φ → ψ,
assume ψ → φ,
and.intro «φ → ψ» «ψ → φ»

lemma iff.right (φ ψ : Prop) : (φ ↔ ψ) → φ → ψ :=
assume φ ↔ ψ,
and.left «φ ↔ ψ»

lemma iff.left (φ ψ : Prop) : (φ ↔ ψ) → ψ → φ :=
assume φ ↔ ψ,
and.right «φ ↔ ψ»

lemma iff.trans (φ ψ ξ : Prop) : (φ ↔ ψ) → (ψ ↔ ξ) → (φ ↔ ξ) :=
assume φ ↔ ψ,
assume ψ ↔ ξ,
iff.intro
  (imp.trans (iff.right «φ ↔ ψ») (iff.right «ψ ↔ ξ»))
  (imp.trans (iff.left «ψ ↔ ξ») (iff.left «φ ↔ ψ»))

lemma exists.map.{u} (P Q : u → Prop) : (∀ x, P x → Q x) → (∃ x, P x) → ∃ x, Q x :=
assume ∀ x, P x → Q x,
assume ∃ x, P x,
obtain (t : u), P t := «∃ x, P x»,
exists.intro («∀ x, P x → Q x»[t] «P t»)

lemma unique.map.{u} (P Q : u → Prop) : (∀ x, P x → Q x) → unique Q → unique P :=
assume ∀ x, P x → Q x,
assume unique Q,
take (x₁ : u),
take (x₂ : u),
assume P x₁,
assume P x₂,
(change ∀ x₁ x₂, Q x₁ → Q x₂ → x₁ = x₂, «unique Q»)[x₁, x₂] («∀ x, P x → Q x»[x₁] «P x₁») («∀ x, P x → Q x»[x₂] «P x₂»)

lemma uexists.congr.{u} (P Q : u → Prop) : (∀ x, P x ↔ Q x) → ((∃! x, P x) ↔ ∃! x, Q x) :=
assume ∀ x, P x ↔ Q x,
have ∀ x, P x → Q x := take (x : u), iff.right «∀ x, P x ↔ Q x»[x],
have ∀ x, Q x → P x := take (x : u), iff.left «∀ x, P x ↔ Q x»[x],
iff.intro
  (assume ∃! x, P x,
    uexists.intro
      (exists.map «∀ x, P x → Q x» (uexists.exists «∃! x, P x»))
      (unique.map «∀ x, Q x → P x» (uexists.unique «∃! x, P x»)))
  (assume ∃! x, Q x,
    uexists.intro
      (exists.map «∀ x, Q x → P x» (uexists.exists «∃! x, Q x»))
      (unique.map «∀ x, P x → Q x» (uexists.unique «∃! x, Q x»)))

def injective.{u, v} (f : u → v) : Prop := ∀ x y, f x = f y → x = y
def surjective.{u, v} (f : u → v) : Prop := ∀ y, ∃ x, y = f x
def bijective.{u, v} (f : u → v) : Prop := injective f ∧ surjective f

/-
lemma bijective.invertible.{u, v} (f : u → v) : bijective f → ∃! (g : v → u), (∀ x, g (f x) = x) ∧ (∀ y, f (g y) = y) :=
assume bijective f,
have injective f := and.left «bijective f»,
have surjective f := and.right «bijective f»,
have ∀ (y : v), ∃! (x : u), y = f x :=
  take (y : v),
  obtain (x : u), y = f x := «surjective f»[y],
  uexists.intro
    (exists.intro «y = f x»)
    (take (x₁ : u),
     take (x₂ : u),
     assume y = f x₁,
     assume y = f x₂,
     have f x₁ = f x₂ := eq.transport «y = f x₁» «y = f x₂»,
     «injective f» «f x₁ = f x₂»),
have ∃! (g : v → u), ∀ (y : v), y = f (g y) := auc «∀ (y : v), ∃! (x : u), y = f x»,
obtain (g : v → u), ∀ (y : v), y = f (g y) := uexists.exists «∃! (g : v → u), ∀ (y : v), y = f (g y)»,
have ∀ (x : u), g (f x) = x :=
  take (x : u),
  have f (g (f x)) = f x := eq.symm «∀ (y : v), y = f (g y)»[f x],
  «injective f» «f (g (f x)) = f x»,
have (∀ (x : u), g (f x) = x) ∧ (∀ (y : v), f (g y) = y) :=
  and.intro «∀ (x : u), g (f x) = x» «∀ (y : v), f (g y) = y»,
uexists.intro
  (exists.intro «(∀ (x : u), g (f x) = x) ∧ (∀ (y : v), f (g y) = y)»)
  (take (h₁ : v → u),
   take (h₂ : v → u),
   assume (∀ (x : u), h₁ (f x) = x) ∧ (∀ (y : v), f (h₁ y) = y),
   assume (∀ (x : u), h₂ (f x) = x) ∧ (∀ (y : v), f (h₂ y) = y),
   have ∀ g₁ g₂, (∀ (x : u), g₁ (f x) = x) ∧ (∀ (y : v), f (g₁ y) = y) → (∀ (x : u), g₂ (f x) = x) ∧ (∀ (y : v), f (g₂ y) = y) → g₁ = g₂ :=
     take (g₁ : v → u),
     take (g₂ : v → u),
     assume (∀ (x : u), g₁ (f x) = x) ∧ (∀ (y : v), f (g₁ y) = y),
     assume (∀ (x : u), g₂ (f x) = x) ∧ (∀ (y : v), f (g₂ y) = y),
     uexists.unique «∃! (g : v → u), ∀ (y : v), y = f (g y)» (and.left «(∀ (x : u), g₁ (f x) = x) ∧ (∀ (y : v), f (g₁ y) = y)») (and.left «(∀ (x : u), g₂ (f x) = x) ∧ (∀ (y : v), f (g₂ y) = y)»),
    «∀ g₁ g₂, (∀ (x : u), g₁ (f x) = x) ∧ (∀ (y : v), f (g₁ y) = y) → (∀ (x : u), g₂ (f x) = x) ∧ (∀ (y : v), f (g₂ y) = y) → g₁ = g₂»[h₁, h₂] «(∀ (x : u), h₁ (f x) = x) ∧ (∀ (y : v), f (h₁ y) = y)» «(∀ (x : u), h₂ (f x) = x) ∧ (∀ (y : v), f (h₂ y) = y)»)
-/

/-
 - type operators
 -/

-- u is a mere proposition
--
--   is_proposition u ≃ u → is_contractible u
--
structure is_proposition u := {
  axiom proposition : ∀ (x₁ x₂ : u), x₁ = x₂
}

instance is_proposition.is_proposition.{u} : is_proposition (is_proposition u) := {
  lemma proposition : ∀ (x₁ x₂ : is_proposition u), x₁ = x₂ := @is_proposition.ext
}

-- TODO: is_prop (is_prop u)
-- TODO: is_prop u → is_prop (v → u)
-- TODO: u → is_prop u ≃ is_prop u
-- TODO: u × is_prop u ≃ is_contr u
-- TODO: is_prop u → u ≃ is_inhab u

-- In HoTT, a type u is called _contractible_ if there uniquely exists an element of u.
--
--   is_contractible u ≃ u × is_proposition u
--
structure is_contractible u := {
  -- Contractibility is usually defined by ∃ (a : u), ∀ (x : u), a = x, but we use ∃! here because
  -- it is more convenient when working with auc.
  axiom contractible : ∃! (a : u), ⊤
}

instance is_contractible.is_proposition.{u} : is_proposition (is_contractible u) := {
  lemma proposition : ∀ (x₁ x₂ : is_contractible u), x₁ = x₂ := @is_contractible.ext
}

-- TODO: is_contr (is_contr u) = is_contr u
-- TODO: u × is_contr u ≃ is_contr u
-- TODO: u → is_contr u ≃ is_prop u
-- TODO: is_contr u → u

-- A type operator sending an inhabited type to its propositional truncation.
-- This type has several names in the literature, such as support type, bracket type, or propositional truncation.
--
-- In the presence of dependent products, this operator corresponds to the law of double negation:
--
--   is_inhabited u ≅ Π (p : Prop), (u → El(p)) → El(p)
--
-- where we assume Prop is a Tarski universe.
structure is_inhabited u := {
  axiom inhabited : ∃ (a : u), ⊤
}

-- TODO: u → is_inhab u
-- TODO: is_prop u → is_inhab u → u
-- TODO: is_prop u → (v → u) → is_inhab v → u

instance is_inhabited.is_proposition.{u} : is_proposition (is_inhabited u) := {
  lemma proposition : ∀ (x₁ x₂ : is_inhabited u), x₁ = x₂ := @is_inhabited.ext
}

-- A type u is called _empty_ if there is no element of u.
--
--   is_empty u ≃ u → empty
--
structure is_empty u := {
  axiom empty : ¬∃ (x : u), ⊤
}

-- A type u is called _nonempty_ if it is not empty.
--
--   is_nonempty u ≃ (u → empty) → empty
--
structure is_nonempty u := {
  axiom nonempty : ¬¬∃ (x : u), ⊤
}

instance is_empty.is_proposition.{u} : is_proposition (is_empty u) := {
  lemma proposition : ∀ (x₁ x₂ : is_empty u), x₁ = x₂ := @is_empty.ext
}

-- Definite description
--
-- This construct exists in any topos.
-- Proof:
--   Let U := { * : 1 | ∃! (x : A), ⊤ }.
--   We prove that there uniquely exists a morphism s : U → A.
--   By definition U ⊩ ∃! (x : A), ⊤.
--   By existence, there exist an epi z : V ->> U and a morphism a : V -> A.
--   Since z is regular, we have a pair p₁,p₂ : V ×[U] V → V such that z = coeq(p₁,p₂).
--   By uniqueness, a p₁ = a p₂. By the universality of coeuqlizers, we obtain s : U → A.
--
-- For a unary predicate φ(x), we can extract the unique element satisfying φ by first passing through the
-- comprehension type t := { x | φ(x) }.
const definite_description.{u} : is_contractible u → u

type inductive empty

def empty_function.{u} : empty → u := λ (x : empty), empty.rec x

lemma empty.initial.{u} : ∃! (f : empty → u), ⊤ :=
uexists.intro
  (@exists.intro[_, empty_function] true.intro)
  (take (f₁ : empty → u), take (f₂ : empty → u), assume ⊤, assume ⊤, fun_ext (take (x : empty), @empty.ind[x, _]))

-- In any topos, the initial object is strict.
lemma empty.strict.{u} (f : u → empty) : bijective f := {
  have injective f :=
    take (x : u),
    @empty.ind[f x, _],
  have surjective f :=
    take (y : empty),
    @empty.ind[y, _],
  and.intro «injective f» «surjective f»
}

-- We can define a type-level negation operator ¬ using the empty type as follows.
--
--   type ¬u := u → empty
--
-- Indeed ¬u is propositionally equivalent to is_empty u.
-- For the direction ¬u → is_empty u, we can construct the evident function as a term,
-- while for the converse direction is_empty u → ¬u, we need to use definite description.
instance type_neg.is_empty.{u} (f : u → empty) : is_empty u := {
  lemma empty : ¬∃ (x : u), ⊤ :=
    assume ∃ (x : u), ⊤,
    obtain (x : u), ⊤ := «∃ (x : u), ⊤»,
    @empty.ind[f x, _]
}

lemma type_neg.is_empty.bijective.{u} : bijective type_neg.is_empty.{u} := {
  have injective type_neg.is_empty :=
    take (f₁ : u → empty),
    take (f₂ : u → empty),
    assume type_neg.is_empty f₁ = type_neg.is_empty f₂,
    fun_ext (take (x : u), @empty.ind[f₁ x, _]),
  have surjective type_neg.is_empty :=
    take (h : is_empty u),
    have ¬∃ (x : u), ⊤ := @is_empty.empty[h],
    have ∀ (x : u), ∃! (y : empty), ⊤ := {
      take (x : u),
      have ∃ (x : u), ⊤ := @exists.intro[_, x] true.intro,
      absurd (contradiction «∃ (x : u), ⊤» «¬∃ (x : u), ⊤»)
    },
    have ∃! (f : u → empty), ∀ (x : u), ⊤ := auc «∀ (x : u), ∃! (y : empty), ⊤»,
    obtain (f : u → empty), ∀ (x : u), ⊤ := uexists.exists «∃! (f : u → empty), ∀ (x : u), ⊤»,
    have h = type_neg.is_empty f := is_empty.is_proposition.proposition,
    exists.intro «h = type_neg.is_empty f»,
  and.intro «injective type_neg.is_empty» «surjective type_neg.is_empty»
}

-- We have an isomorphism between `is_empty u` and `u → empty`.
lemma empty_function.uexists.{u, v} : ¬(∃ (x : u), ⊤) → ∃! (f : u → v), ⊤ :=
assume ¬(∃ (x : u), ⊤),
have ∀ (x : u), ∃! (y : v), ⊤ := {
  take (x : u),
  have ∃ (x : u), ⊤ := @exists.intro[_, x] true.intro,
  absurd (contradiction «∃ (x : u), ⊤» «¬∃ (x : u), ⊤»)
},
have ∃! (f : u → v), ∀ (x : u), ⊤ := auc «∀ (x : u), ∃! (y : v), ⊤»,
have ∀ (f : u → v), (∀ (x : u), ⊤) ↔ ⊤ := {
  take (f : u → v),
  have (∀ (x : u), ⊤) → ⊤ := {
    assume ∀ x, ⊤,
    true.intro
  },
  have ⊤ → ∀ (x : u), ⊤ := {
    assume ⊤,
    take (x : u),
    true.intro
  },
  iff.intro «(∀ (x : u), ⊤) → ⊤» «⊤ → ∀ (x : u), ⊤»
},
iff.right (uexists.congr «∀ (f : u → v), (∀ (x : u), ⊤) ↔ ⊤») «∃! (f : u → v), ∀ (x : u), ⊤»

instance EmptyFunction.is_contractible.{u, v} (h : is_empty u) : is_contractible (u → v) := {
  lemma contractible : ∃! (f : u → v), ⊤ := empty_function.uexists @is_empty.empty[h]
}

/-
structure sum u v := {
  const s : sub u
  const t : sub v
  axiom spec₁ : (∃! x, x ∈ s) ∨ (∃! y, y ∈ t)
  axiom spec₂ : ∀ x y, ¬(x ∈ s ∧ y ∈ t)
}
-/

structure u := {}
structure v := {}

const F : v → u
const G : v → u

-- equivalence closure
inductive ec : u → u → Prop
| base (a : v) : ec (F a) (G a)
| refl (x : u) : ec x x
| symm (x y : u) : ec x y → ec y x
| trans (x y z : u) : ec x y → ec y z → ec x z

structure quot := {
  const rep : u → Prop
  axiom spec : ∃ x, ec x = rep
}

instance into_quot (x : u) : quot := {
  def rep : u → Prop := ec x
  lemma spec : ∃ x, ec x = rep := exists.intro eq.refl
}

-- def empty_function.{u, v} [has (is_empty u)] : u → v := definite_description (EmptyFunction.is_contractible summon)


-- The type of decidable propositions.
--
-- The structure command below is desugared into the following set of declarations.
--
--   type const bool : Type
--   const bool.rec.{α} : bool → (Prop → α) → α
--   def bool.rep : bool → Prop := λ (this : bool), bool.rec.{Prop} this (λ (rep : Prop), rep)
--   axiom bool.spec.{u} (this : bool) : bool.rep this = ⊤ ∨ bool.rep this = ⊥
--   axiom bool.abs.{u, α} (rep : Prop) : rep = ⊤ ∨ rep = ⊥ → ∃ this, bool.rec.{α} this = λ (f : Prop → α), f rep
--   axiom bool.ext.{u} (this₁ this₂ : bool) : bool.rep this₁ = bool.rep this₂ → this₁ = this₂
--
-- Of course, bool can be also defined in terms of an inductive type.
--
--   type inductive bool
--   | tt : bool
--   | ff : bool
--
-- We avoid this because we are in the bootstrapping process; existence of (all) inductive types
-- relies on the existence of an infinite type. By defining bool using structure it should be clear
-- that we don't need such an assumption.
--
structure bool := {
  const rep : Prop
  axiom spec : rep = ⊤ ∨ rep = ⊥
}

-- This command introduces:
--
--   def bool.tt.rep : Prop := ⊤
--   lemma bool.tt.spec : bool.tt.rep = ⊤ ∨ bool.tt.rep = ⊥ := tt_spec
--   const bool.tt : bool
--   axiom bool.tt.rec.{α} : bool.rec bool.tt = λ (f : Prop → α), f bool.tt.rep
--
instance bool.tt : bool := {
  def rep : Prop := ⊤
  -- TODO: name collision
  lemma spec : rep = ⊤ ∨ rep = ⊥ := or.left eq.refl
}

instance bool.ff : bool := {
  def rep : Prop := ⊥
  lemma spec : rep = ⊤ ∨ rep = ⊥ := or.right eq.refl
}

class instance bool.default : default bool := {
  def value : bool := bool.tt
}

def tt : bool := bool.tt
def ff : bool := bool.ff

lemma bool.rep_tt_eq_true : bool.rep tt = ⊤ :=
calc bool.rep tt = bool.rec tt (λ rep, rep)          := eq.refl
             ... = (λ f, f bool.tt.rep) (λ rep, rep) := eq.ap bool.tt.rec
             ... = ⊤                                 := eq.refl

lemma bool.rep_ff_eq_false : bool.rep ff = ⊥ :=
calc bool.rep ff = bool.rec ff (λ rep, rep)          := eq.refl
             ... = (λ f, f bool.ff.rep) (λ rep, rep) := eq.ap bool.ff.rec
             ... = ⊥                                 := eq.refl

lemma bool.eq_tt (b : bool) : bool.rep b = ⊤ → b = tt :=
assume bool.rep b = ⊤,
bool.ext (
  calc bool.rep b = ⊤           := «bool.rep b = ⊤»
              ... = bool.rep tt := eq.symm bool.rep_tt_eq_true
)

lemma bool.eq_ff (b : bool) : bool.rep b = ⊥ → b = ff :=
assume bool.rep b = ⊥,
bool.ext (
  calc bool.rep b = ⊥           := «bool.rep b = ⊥»
              ... = bool.rep ff := eq.symm bool.rep_ff_eq_false
)

lemma bool.case (b : bool) : b = tt ∨ b = ff :=
or.ind bool.spec
  (assume bool.rep b = ⊤,
   or.left (bool.eq_tt «bool.rep b = ⊤»))
  (assume bool.rep b = ⊥,
   or.right (bool.eq_ff «bool.rep b = ⊥»))

lemma bool.tt_ne_ff : tt ≠ ff :=
assume tt = ff,
contradiction
  (calc ⊤ = bool.rep tt := eq.symm bool.rep_tt_eq_true
        ... = bool.rep ff := eq.ap «tt = ff»
        ... = ⊥           := bool.rep_ff_eq_false)
  true_ne_false

/-
lemma bool.ite.uexists.{u} : ∃! (ite : bool → u → u → u), ∀ (b : bool) (x y : u), ite tt x y = x ∧ ite ff x y = y :=
have ∀ (b : bool) (x y : u), ∃! (z : u), (b = tt → z = x) ∧ (b = ff → z = y) :=
  take (b : bool),
  take (x : u),
  take (y : u),
  or.ind bool.case
    (assume b = tt,
     exists.intro (and.intro (assume b = tt, eq.refl) (assume b = ff, absurd (contradiction (eq.transport «b = tt» «b = ff») true_ne_false))))
    (assume b = ff,
     exists.intro (and.intro (assume b = tt, absurd (contradiction (eq.symm (eq.transport «b = ff» «b = tt»)) true_ne_false)) (assume b = ff, eq.refl))),

structure bool.ite_box u := {
  const ite : bool → u → u → u
  axiom spec : ∀ (b : bool) (x y : u), ite tt x y = x ∧ ite ff x y = y
}

instance bool.ite_box.is_contractible.{u} : is_contractible (bool.ite_box u) := {
  lemma contractible : ∃! (b : bool.ite_box u), ⊤ := {
    obtain (ite : bool → u → u → u), ∀ (b : bool) (x y : u), ite tt x y = x ∧ ite ff x y = y := bool.ite.uexists,
    bool.ite_box.abs «∀ (b : bool) (x y : u), ite tt x y = x ∧ ite ff x y = y»
  }
}

def bool.ite.{u} : bool → u → u → u := definite_description (bool.ite_box.is_contractible)
-/

/-
 - Extensionality
 -/

lemma eq.congr_abs.{u, v} (m₁ m₂ : u) : (∀ (x : v), m₁ = m₂) → (λ (x : v), m₁) = (λ (x : v), m₂) :=
assume ∀ (x : v), m₁ = m₂,
fun_ext «∀ (x : v), m₁ = m₂»

lemma eta_expand.{u, v} (f : u → v) : f = λ x, f x :=
-- FIXME: the unifier is unable to synthesize `f` (for some reasons).
@fun_ext[f, _] (take (x : u), eq.refl)

/-
 - functions
 -/

lemma lawvere_fixpoint.{u, v} (f : v → v) : (∃ (e : u → u → v), surjective e) → ∃ y, y = f y :=
assume ∃ (e : u → u → v), surjective e,
obtain (e : u → u → v), surjective e := «∃ (e : u → u → v), surjective e»,
obtain (x : u), (λ x, f (e x x)) = e x := «surjective e»[λ x, f (e x x)],
have f (e x x) = e x x := eq.congr_fun «(λ x, f (e x x)) = e x»,
exists.intro (eq.symm «f (e x x) = e x x»)

lemma injective.unique.{u, v} (f : u → v) (y : v) : injective f → unique (λ x, y = f x) :=
assume injective f,
take (x₁ : u),
take (x₂ : u),
assume y = f x₁,
assume y = f x₂,
(change ∀ x y, f x = f y → x = y, «injective f»)[x₁, x₂] (eq.trans (eq.symm «y = f x₁») «y = f x₂»)

def split.{u, v} (f : u → v) : Prop := ∃ g, ∀ y, y = f (g y)

/-
 - subsets
 -/

infix ∈ : 50 := in
infix ∉ : 50 := notin
infix ⊆ : 50 := subset
infixl ∩ : 70 := cap
infixl ∪ : 65 := cup
infix ∖ : 70 := setminus
nofix ∅ := emptyset

-- TODO: type sub u := u → Prop

def in.{u} (x : u) (s : sub u) : Prop := s x
def notin.{u} (x : u) (s : sub u) : Prop := ¬(x ∈ s)
def univ.{u} : sub u := λ x, ⊤
def emptyset.{u} : sub u := λ x, ⊥
def subset.{u} (s : sub u) (t : sub u) : Prop := ∀ x, x ∈ s → x ∈ t
def sep.{u} (s : sub u) (φ : u → Prop) : sub u := λ x, x ∈ s ∧ φ x
def cap.{u} (s : sub u) (t : sub u) : sub u := { x | x ∈ s ∧ x ∈ t }
def cup.{u} (s : sub u) (t : sub u) : sub u := { x | x ∈ s ∨ x ∈ t }
def bigcap.{u} (a : sub (sub u)) : sub u := { x | ∀ s, s ∈ a → x ∈ s }
def bigcup.{u} (a : sub (sub u)) : sub u := { x | ∃ s, s ∈ a ∧ x ∈ s }
def power.{u} (s : sub u) : sub (sub u) := { t | t ⊆ s }
def setminus.{u} (s : sub u) (t : sub u) : sub u := { x | x ∈ s ∧ x ∉ t }
def im.{u, v} (f : u → v) (s : sub u) : sub v := { y | ∃ x, x ∈ s ∧ y = f x }
def insert.{u} (a : u) (s : sub u) : sub u := { x | x = a ∨ x ∈ s }

lemma set.ext.{u} (s t : sub u) : (∀ x, x ∈ s ↔ x ∈ t) → s = t :=
assume ∀ x, x ∈ s ↔ x ∈ t,
fun_ext (take (x : u), prop_ext («∀ x, x ∈ s ↔ x ∈ t»[x]))

lemma subset.trans.{u} (s t r : sub u) : s ⊆ t → t ⊆ r → s ⊆ r :=
assume s ⊆ t,
assume t ⊆ r,
take (x : u),
assume x ∈ s,
have x ∈ t := «s ⊆ t»[x] «x ∈ s»,
«t ⊆ r»[x] «x ∈ t»

lemma subset.refl.{u} (s : sub u) : s ⊆ s :=
take (x : u),
assume x ∈ s,
«x ∈ s»

lemma subset.antisymm.{u} (s t : sub u) : s ⊆ t → t ⊆ s → s = t :=
assume s ⊆ t,
assume t ⊆ s,
have ∀ x, x ∈ s ↔ x ∈ t :=
  take (x : u),
  iff.intro («s ⊆ t»[x]) («t ⊆ s»[x]),
set.ext «∀ x, x ∈ s ↔ x ∈ t»

-- Note: Consolas does not display well the cap and bigcap symbols:
--
--    ∩  U+2229 INTERSECTION
--    ⋂  U+22C2 N-ARY INTERSECTION
--
-- We can perhaps use instead ⋒ U+22D2 DOUBLE INTERSECTION.
-- In Lean, two character symbols ⋂₀ and ⋃₀ are adopted but I could not find their origin on the internet.
-- https://github.com/leanprover/lean3/pull/936/commits/549feb5d7f95c0d28450b3778d471becafe58046
prefix ⋂ : 110 := bigcap
prefix ⋃ : 110 := bigcup

lemma bigcap.lower_bound.{u} (a : sub (sub u)) (s : sub u) : s ∈ a → ⋂ a ⊆ s :=
assume s ∈ a,
take (x : u),
assume x ∈ ⋂ a,
«x ∈ ⋂ a»[s] «s ∈ a»

-- While Sub(X) is not a complete Heyting lattice object, it is indeed internally complete as this lemma shows.
lemma bigcap.universal.{u} (a : sub (sub u)) (s : sub u) : (∀ t, t ∈ a → s ⊆ t) → s ⊆ ⋂ a :=
assume ∀ t, t ∈ a → s ⊆ t,
take (x : u),
assume x ∈ s,
have x ∈ ⋂ a :=
  take (t : sub u),
  assume t ∈ a,
  have s ⊆ t := «∀ t, t ∈ a → s ⊆ t»[t] «t ∈ a»,
  «s ⊆ t»[x] «x ∈ s»,
«x ∈ ⋂ a»

lemma bigcup.upper_bound.{u} (a : sub (sub u)) (s : sub u) : s ∈ a → s ⊆ ⋃ a :=
assume s ∈ a,
take (x : u),
assume x ∈ s,
@exists.intro[_, s] (and.intro «s ∈ a» «x ∈ s»)

def monotone.{u} (f : sub u → sub u) : Prop := ∀ s t, s ⊆ t → f s ⊆ f t

def mu.{u} (f : sub u → sub u) : sub u := ⋂ { s | f s ⊆ s }

lemma mu.lower_bound.{u} (f : sub u → sub u) (s : sub u) : f s ⊆ s → mu f ⊆ s := bigcap.lower_bound

lemma mu.is_prefix.{u} (f : sub u → sub u) : monotone f → f (mu f) ⊆ mu f :=
assume monotone f,
have ∀ s, f s ⊆ s → f (mu f) ⊆ s :=
  take (s : sub u),
  assume f s ⊆ s,
  have mu f ⊆ s := mu.lower_bound «f s ⊆ s»,
  have f (mu f) ⊆ f s := «monotone f»[mu f, s] «mu f ⊆ s»,
  subset.trans «f (mu f) ⊆ f s» «f s ⊆ s»,
bigcap.universal «∀ s, f s ⊆ s → f (mu f) ⊆ s»

lemma mu.is_postfix.{u} (f : sub u → sub u) : monotone f → mu f ⊆ f (mu f) :=
assume monotone f,
have f (mu f) ⊆ mu f := mu.is_prefix «monotone f»,
have f (f (mu f)) ⊆ f (mu f) := «monotone f»[f (mu f), mu f] «f (mu f) ⊆ mu f»,
mu.lower_bound «f (f (mu f)) ⊆ f (mu f)»

lemma mu.fixed_point.{u} (f : sub u → sub u) : monotone f → mu f = f (mu f) :=
assume monotone f,
have f (mu f) ⊆ mu f := mu.is_prefix «monotone f»,
have mu f ⊆ f (mu f) := mu.is_postfix «monotone f»,
subset.antisymm «mu f ⊆ f (mu f)» «f (mu f) ⊆ mu f»

-- Knaster-Tarski
lemma mu.least_fixed_point.{u} (f : sub u → sub u) : monotone f → mu f = f (mu f) ∧ (∀ s, s = f s → mu f ⊆ s) :=
assume monotone f,
have mu f = f (mu f) := mu.fixed_point «monotone f»,
have ∀ s, s = f s → mu f ⊆ s :=
  take (s : sub u),
  assume s = f s,
  have f s ⊆ s := eq.transport «s = f s» subset.refl,
  mu.lower_bound «f s ⊆ s»,
and.intro «mu f = f (mu f)» «∀ s, s = f s → mu f ⊆ s»

lemma cantor.{u} : ¬(∃ (e : u → sub u), surjective e) :=
mt lawvere_fixpoint (
  assume ∃ φ, φ = ¬φ,
  obtain (φ : Prop), φ = ¬φ := «∃ φ, φ = ¬φ»,
  contradiction «φ = ¬φ» not.fixed_point_free)

def preimage.{u, v} (f : u → v) (t : sub v) : sub u := { x | t (f x) }

inductive fin.{u} : sub u → Prop
| empty : fin emptyset
| insert (a : u) (s : sub u) : fin s → fin (insert a s)

-- The type of inhabited subsets.
structure inhab u := {
  const rep : sub u
  axiom inhabited : ∃ x, x ∈ rep
}

lemma inhab.uabs.{u} (s : sub u) : (∃ x, x ∈ s) → ∃! c, s = inhab.rep c :=
assume ∃ x, x ∈ s,
-- TODO: add obtain instance syntax
--
--   obtain instance c : inhab u := {
--     def rep : sub u := s
--     lemma inhabited : ∃ x, x ∈ rep := «∃ x, x ∈ s»
--   },
--
-- which is desugared to
--
--   let c.rep : sub u := s,
--   have c.inhabited : ∃ x, x ∈ c.rep := «∃ x, x ∈ s»,
--   obtain (c : bool), inhab.rec c = λ (f : sub u → α), f c.rep := @inhab.abs[c.rep] c.inhabited,
--
obtain (c : inhab u), s = inhab.rep c := inhab.abs «∃ x, x ∈ s»,
uexists.intro
  (exists.intro «s = inhab.rep c»)
  (take (c₁ : inhab u),
   take (c₂ : inhab u),
   assume s = inhab.rep c₁,
   assume s = inhab.rep c₂,
   have inhab.rep c₁ = inhab.rep c₂ := eq.trans (eq.symm «s = inhab.rep c₁») «s = inhab.rep c₂»,
   inhab.ext «inhab.rep c₁ = inhab.rep c₂»)

/-
 - axiom of choice
 -/

axiom ac.{u, v} (R : u → v → Prop) : (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x)

lemma surjective.split.{u, v} (f : u → v) : surjective f → split f := ac

type inductive prod u v
| pair : u → v → prod

def prod.fst.{u, v} (p : u × v) : u := prod.rec p (λ a b, a)
def prod.snd.{u, v} (p : u × v) : v := prod.rec p (λ a b, b)

def fst.{u, v} : u × v → u := prod.fst
def snd.{u, v} : u × v → v := prod.snd
def pair.{u, v} : u → v → u × v := prod.pair

lemma fst.pair.{u, v} (x : u) (y : v) : fst (pair x y) = x :=
eq.congr_fun prod.pair.spec

lemma snd.pair.{u, v} (x : u) (y : v) : snd (pair x y) = y :=
eq.congr_fun prod.pair.spec

lemma prod.eta.{u, v} (p : u × v) : p = pair (fst p) (snd p) :=
@prod.ind[p, λ p, p = pair (fst p) (snd p)]
  (take (a : u),
   take (b : v),
   calc pair a b = pair (fst (pair a b)) b := eq.transport (eq.symm fst.pair) eq.refl
        ...      = pair (fst (pair a b)) (snd (pair a b)) := eq.transport (eq.symm snd.pair) eq.refl)

structure total u v := {
  const rel : u → v → Prop
  axiom spec : ∀ x, ∃ y, rel x y
}

structure total.el u v := {
  const rel : total u v
  const x : u
  const y : v
  axiom spec : total.rel rel x y
}

def f.{u, v} : total.el u v → u × total u v := λ (e : total.el u v), prod.pair (total.el.x e) (total.el.rel e)

lemma f.surjective.{u, v} : surjective f.{u, v} := {
  take (p : u × total u v),
  have ∃ (y : v), total.rel (snd p) (fst p) y := total.spec,
  obtain (y : v), total.rel (snd p) (fst p) y := «∃ (y : v), total.rel (snd p) (fst p) y»,
  have ∃ (e : total.el u v), snd p = total.el.rel e ∧ fst p = total.el.x e ∧ y = total.el.y e :=
    total.el.abs «total.rel (snd p) (fst p) y»,
  obtain (e : total.el u v), snd p = total.el.rel e ∧ fst p = total.el.x e ∧ y = total.el.y e :=
    «∃ (e : total.el u v), snd p = total.el.rel e ∧ fst p = total.el.x e ∧ y = total.el.y e»,
  have snd p = total.el.rel e := and.left (and.left «snd p = total.el.rel e ∧ fst p = total.el.x e ∧ y = total.el.y e»),
  have fst p = total.el.x e := and.right (and.left «snd p = total.el.rel e ∧ fst p = total.el.x e ∧ y = total.el.y e»),
  have p = pair (total.el.x e) (total.el.rel e) :=
    calc p = pair (fst p) (snd p)                    := prod.eta
         ... = pair (total.el.x e) (snd p)           := eq.transport «fst p = total.el.x e» eq.refl
         ... = pair (total.el.x e) (total.el.rel e)  := eq.transport «snd p = total.el.rel e» eq.refl,
  @exists.intro[_, e] «p = pair (total.el.x e) (total.el.rel e)»
}

lemma total.choice.exists.{u, v} (r : total u v) : ∃ h, ∀ x, total.rel r x (h x) :=
obtain (g : u × total u v → total.el u v), ∀ p, p = f (g p) := surjective.split f.surjective,
@exists.intro[_, λ x, total.el.y (g (pair x r))]
  take (x : u),
  have pair x r = f (g (pair x r)) := «∀ p, p = f (g p)»[_],
  have x = total.el.x (g (pair x r)) :=
    calc x = fst (pair x r)                            := eq.symm fst.pair
         ... = fst (f (g (pair x r)))                  := eq.congr_arg «pair x r = f (g (pair x r))»
         ... = total.el.x (g (pair x r))               := fst.pair,
  have r = total.el.rel (g (pair x r)) :=
    calc r = snd (pair x r)                            := eq.symm snd.pair
         ... = snd (f (g (pair x r)))                  := eq.congr_arg «pair x r = f (g (pair x r))»
         ... = total.el.rel (g (pair x r))             := snd.pair,
  have total.rel r x (total.el.y (g (pair x r))) :=
    eq.transport (eq.symm «r = total.el.rel (g (pair x r))») (eq.transport (eq.symm «x = total.el.x (g (pair x r))») @total.el.spec[g (pair x r)]),
  «total.rel r x (total.el.y (g (pair x r)))»

lemma ac_from_surjective_split.{u, v} (R : u → v → Prop) : (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) :=
assume ∀ x, ∃ y, R x y,
obtain (r : total u v), R = total.rel r := total.abs «∀ x, ∃ y, R x y»,
obtain (h : u → v), ∀ x, total.rel r x (h x) := total.choice.exists,
@exists.intro[_, h] (take (x : u),
  have R x (h x) :=
    eq.transport (eq.symm «R = total.rel r») «∀ x, total.rel r x (h x)»[x],
  «R x (h x)»)

def choice.{u} (f : inhab u → u) : Prop := ∀ (x : inhab u), f x ∈ inhab.rep x

-- choice function exists for any inhabited type
-- this is an equivalent formulation of ac
-- later we will introduce a constructive version of this lemma, called `global_choice`.
lemma choice.exists.{u} : ∃ (f : inhab u → u), choice f :=
ac @inhab.inhabited

lemma ac_from_choice_exists.{u, v} (R : u → v → Prop) : (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) :=
obtain (c : inhab v → v), choice c := choice.exists,
assume ∀ x, ∃ y, R x y,
have ∀ x, ∃! (s : inhab v), R x = inhab.rep s :=
  take (x : u),
  have ∃ (y : v), R x y := «∀ x, ∃ y, R x y»[x],
    -- FIXME: the unifier could not synthesize `R x`
  @inhab.uabs[R x] «∃ (y : v), R x y»,
have ∃! (g : u → inhab v), ∀ x, R x = inhab.rep (g x) := auc «∀ x, ∃! (s : inhab v), R x = inhab.rep s»,
obtain (g : u → inhab v), ∀ x, R x = inhab.rep (g x) := uexists.exists «∃! (g : u → inhab v), ∀ x, R x = inhab.rep (g x)»,
@exists.intro[_, λ x, c (g x)] (take (x : u),
  have c (g x) ∈ inhab.rep (g x) := «choice c»[g x],
  eq.transport (eq.symm «∀ x, R x = inhab.rep (g x)»[x]) «c (g x) ∈ inhab.rep (g x)»)

-- Diaconescu's argument: ac + prop_ext + fun_ext → em
--
-- The bool type having a choice function is in fact equivalent to em.
-- While em implies (using prop_ext) Prop is _internally two-valued_ i.e.
-- ∀ φ, φ = ⊤ ∨ φ = ⊥, the ambient topos may not be (externally) two-valued;
-- it only implies the topos is boolean.
lemma em (φ : Prop) : φ ∨ ¬φ := {
  have ∃ b, φ ∨ b = tt := exists.intro (or.right eq.refl),
  have ∃ b, φ ∨ b = ff := exists.intro (or.right eq.refl),
  obtain (h₁ : inhab bool), (λ b, φ ∨ b = tt) = inhab.rep h₁ := inhab.abs «∃ b, φ ∨ b = tt»,
  obtain (h₂ : inhab bool), (λ b, φ ∨ b = ff) = inhab.rep h₂ := inhab.abs «∃ b, φ ∨ b = ff»,
  obtain (c : inhab bool → bool), choice c := choice.exists,
  have φ → c h₁ = c h₂ :=
    assume φ,
    have (λ b, φ ∨ b = tt) = (λ b, φ ∨ b = ff) := fun_ext (
      take (b : bool),
      have φ ∨ b = tt := or.left «φ»,
      have φ ∨ b = ff := or.left «φ»,
      prop_ext (iff.intro (assume φ ∨ b = tt, «φ ∨ b = ff») (assume φ ∨ b = ff, «φ ∨ b = tt»))
    ),
    have inhab.rep h₁ = inhab.rep h₂ :=
      eq.trans (eq.symm «(λ b, φ ∨ b = tt) = inhab.rep h₁») (eq.trans «(λ b, φ ∨ b = tt) = (λ b, φ ∨ b = ff)» «(λ b, φ ∨ b = ff) = inhab.rep h₂»),
    have h₁ = h₂ :=
      inhab.ext «inhab.rep h₁ = inhab.rep h₂»,
    eq.congr_arg «h₁ = h₂»,
  have φ ∨ c h₁ = tt :=
    eq.transport (eq.symm (eq.congr_fun «(λ b, φ ∨ b = tt) = inhab.rep h₁»)) «choice c»[h₁],
  have φ ∨ c h₂ = ff :=
    eq.transport (eq.symm (eq.congr_fun «(λ b, φ ∨ b = ff) = inhab.rep h₂»)) «choice c»[h₂],
  have φ ∨ c h₁ ≠ c h₂ :=
    or.ind «φ ∨ c h₁ = tt»
      (assume φ, or.left «φ»)
      (assume c h₁ = tt,
        or.ind «φ ∨ c h₂ = ff»
          (assume φ, or.left «φ»)
          (assume c h₂ = ff,
            or.right (eq.transport (eq.symm «c h₂ = ff») (eq.transport (eq.symm «c h₁ = tt») bool.tt_ne_ff)))),
  or.ind «φ ∨ c h₁ ≠ c h₂»
    (assume φ,
      or.left «φ»)
    (assume c h₁ ≠ c h₂,
      or.right (mt «φ → c h₁ = c h₂» «c h₁ ≠ c h₂»))
}

-- double negation elimination
lemma dne (φ : Prop) : ¬¬φ → φ :=
assume ¬¬φ,
or.ind em
  (assume φ,
   «φ»)
  (assume ¬φ,
   absurd (contradiction «¬φ» «¬¬φ»))

lemma peirce (φ ψ : Prop) : ((φ → ψ) → φ) → φ :=
or.ind em
  (assume φ,
   assume (φ → ψ) → φ,
   «φ»)
  (assume ¬φ,
   assume (φ → ψ) → φ,
   have φ → ψ := assume φ, absurd (contradiction «φ» «¬φ»),
   «(φ → ψ) → φ» «φ → ψ»)

lemma imp.to_or (φ ψ : Prop) : (φ → ψ) → ¬φ ∨ ψ :=
assume φ → ψ,
or.ind em
  (assume φ,
   have ψ := «φ → ψ» «φ»,
   or.right «ψ»)
  (assume ¬φ,
   or.left «¬φ»)

lemma or.to_imp (φ ψ : Prop) : ¬φ ∨ ψ → φ → ψ :=
assume ¬φ ∨ ψ,
assume φ,
or.ind «¬φ ∨ ψ»
  (assume ¬φ,
   absurd (contradiction «φ» «¬φ»))
  (assume ψ,
   «ψ»)

-- An intermediate axiom. This is strictly weaker than em.
lemma godel_dummet (φ ψ : Prop) : (φ → ψ) ∨ (ψ → φ) :=
or.ind em
  (assume φ,
   have ¬ψ ∨ φ := or.right «φ»,
   or.right (or.to_imp «¬ψ ∨ φ»))
  (assume ¬φ,
   have ¬φ ∨ ψ := or.left «¬φ»,
   or.left (or.to_imp «¬φ ∨ ψ»))

-- equivalent to the Gödel-Dummet axiom
lemma imp.right_distr_or (φ ψ ξ : Prop) : (φ → ψ ∨ ξ) → (φ → ψ) ∨ (φ → ξ) :=
assume φ → ψ ∨ ξ,
or.ind godel_dummet
  (assume ψ → ξ,
   have φ → ξ :=
     assume φ,
     have ψ ∨ ξ := «φ → ψ ∨ ξ» «φ»,
     or.ind «ψ ∨ ξ»
       (assume ψ,
        «ψ → ξ» «ψ»)
       (assume ξ,
        «ξ»),
   or.right «φ → ξ»)
  (assume ξ → ψ,
   have φ → ψ :=
     assume φ,
     have ψ ∨ ξ := «φ → ψ ∨ ξ» «φ»,
     or.ind «ψ ∨ ξ»
       (assume ψ,
        «ψ»)
       (assume ξ,
        «ξ → ψ» «ξ»),
   or.left «φ → ψ»)

-- generalized excluded middle. This is equivalent to em in the presence of ex falso.
lemma gem (φ ψ : Prop) : φ ∨ (φ → ψ) :=
or.ind em
  (assume φ,
   or.left «φ»)
  (assume ¬φ,
   have φ → ψ :=
     assume φ,
     absurd (contradiction «φ» «¬φ»),
   or.right «φ → ψ»)

def inhabited.{u} : Prop := ∃ (a : u), ⊤
def empty.{u} : Prop := ¬inhabited.{u}

-- (The dual of) the drinker paradox. This is equivalent to independence_of_premise.
lemma drinker_paradox.{u} (P : u → Prop) : inhabited.{u} → ∃ x, (∃ y, P y) → P x :=
assume inhabited.{u},
or.ind em
  (assume ∃ y, P y,
   obtain (y : u), P y := «∃ y, P y»,
   @exists.intro[_, y]
     (assume ∃ y, P y,
      «P y»))
  (assume ¬∃ y, P y,
   obtain (x : u), ⊤ := «inhabited.{u}»,
   @exists.intro[_, x]
    (assume ∃ y, P y,
     @absurd[P x] (contradiction «∃ y, P y» «¬∃ y, P y»)))

-- Independence of (general) premise. This is equivalent to the drinker paradox.
lemma independence_of_premise.{u} (P : u → Prop) (φ : Prop) : inhabited.{u} → (φ → ∃ x, P x) → (∃ x, φ → P x) :=
assume inhabited.{u},
assume φ → ∃ x, P x,
obtain (x : u), (∃ y, P y) → P x := drinker_paradox «inhabited.{u}»,
have φ → P x := imp.trans «φ → ∃ x, P x» «(∃ y, P y) → P x»,
exists.intro «φ → P x»

-- This is equivalent to axiom of choice.
lemma some.exists.{u} : inhabited.{u} → ∃ (ε : (u → Prop) → u), ∀ P, (∃ y, P y) → P (ε P) :=
assume inhabited.{u},
ac (take (P : u → Prop), drinker_paradox «inhabited.{u}»)

lemma ac_for_inhabited.{u, v} (R : u → v → Prop) : inhabited.{v} → (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) :=
assume inhabited.{v},
assume ∀ x, ∃ y, R x y,
obtain (ε : (v → Prop) → v), ∀ P, (∃ y, P y) → P (ε P) := some.exists «inhabited.{v}»,
@exists.intro[_, (λ x, ε (R x))]
  (take (x : u),
   have ∃ y, R x y := «∀ x, ∃ y, R x y»[_],
   have (∃ y, R x y) → R x (ε (R x)) := «∀ P, (∃ y, P y) → P (ε P)»[R x],
   have R x (ε (R x)) := «(∃ y, R x y) → R x (ε (R x))» «∃ y, R x y»,
   «R x (ε (R x))»)

lemma ac_for_empty.{u, v} (R : u → v → Prop) : empty.{v} → (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) :=
assume empty.{v},
assume ∀ x, ∃ y, R x y,
have ∀ (x : u), ⊥ :=
  take (x : u),
  have ∃ y, R x y := «∀ x, ∃ y, R x y»[_],
  obtain (y : v), R x y := «∃ y, R x y»,
  have inhabited.{v} :=
    @exists.intro[_, y] true.intro,
  contradiction «inhabited.{v}» «empty.{v}»,
have ∀ x, ∃! y, R x y :=
  take (x : u),
  absurd «∀ (x : u), ⊥»[x],
have ∃! (f : u → v), ∀ x, R x (f x) := auc «∀ x, ∃! y, R x y»,
uexists.exists «∃! (f : u → v), ∀ x, R x (f x)»

lemma bool.has_choice : ∃ (f : inhab bool → bool), choice.{bool} f :=
ac_for_inhabited (@exists.intro[_, bool.tt] true.intro) @inhab.inhabited

lemma em_from_some_exists (φ : Prop) : φ ∨ ¬φ := {
  have ∃ b, φ ∨ b = tt := exists.intro (or.right eq.refl),
  have ∃ b, φ ∨ b = ff := exists.intro (or.right eq.refl),
  obtain (h₁ : inhab bool), (λ b, φ ∨ b = tt) = inhab.rep h₁ := inhab.abs «∃ b, φ ∨ b = tt»,
  obtain (h₂ : inhab bool), (λ b, φ ∨ b = ff) = inhab.rep h₂ := inhab.abs «∃ b, φ ∨ b = ff»,
  obtain (c : inhab bool → bool), choice c := bool.has_choice,
  have φ → c h₁ = c h₂ :=
    assume φ,
    have (λ b, φ ∨ b = tt) = (λ b, φ ∨ b = ff) := fun_ext (
      take (b : bool),
      have φ ∨ b = tt := or.left «φ»,
      have φ ∨ b = ff := or.left «φ»,
      prop_ext (iff.intro (assume φ ∨ b = tt, «φ ∨ b = ff») (assume φ ∨ b = ff, «φ ∨ b = tt»))
    ),
    have inhab.rep h₁ = inhab.rep h₂ :=
      eq.trans (eq.symm «(λ b, φ ∨ b = tt) = inhab.rep h₁») (eq.trans «(λ b, φ ∨ b = tt) = (λ b, φ ∨ b = ff)» «(λ b, φ ∨ b = ff) = inhab.rep h₂»),
    have h₁ = h₂ :=
      inhab.ext «inhab.rep h₁ = inhab.rep h₂»,
    eq.congr_arg «h₁ = h₂»,
  have φ ∨ c h₁ = tt :=
    eq.transport (eq.symm (eq.congr_fun «(λ b, φ ∨ b = tt) = inhab.rep h₁»)) «choice c»[h₁],
  have φ ∨ c h₂ = ff :=
    eq.transport (eq.symm (eq.congr_fun «(λ b, φ ∨ b = ff) = inhab.rep h₂»)) «choice c»[h₂],
  have φ ∨ c h₁ ≠ c h₂ :=
    or.ind «φ ∨ c h₁ = tt»
      (assume φ, or.left «φ»)
      (assume c h₁ = tt,
        or.ind «φ ∨ c h₂ = ff»
          (assume φ, or.left «φ»)
          (assume c h₂ = ff,
            or.right (eq.transport (eq.symm «c h₂ = ff») (eq.transport (eq.symm «c h₁ = tt») bool.tt_ne_ff)))),
  or.ind «φ ∨ c h₁ ≠ c h₂»
    (assume φ,
      or.left «φ»)
    (assume c h₁ ≠ c h₂,
      or.right (mt «φ → c h₁ = c h₂» «c h₁ ≠ c h₂»))
}

lemma ac_from_some_exists.{u, v} (R : u → v → Prop) : (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) :=
or.ind em_from_some_exists
  (assume inhabited.{v},
   ac_for_inhabited «inhabited.{v}»)
  (assume empty.{v},
   ac_for_empty «empty.{v}»)

/-
 - Indefinite description
 -/

-- We can already prove the existence of a choice function for any inhabited type u.
lemma indefinite_description.exists.{u} : ∃ (indefinite_description : is_inhabited u → u), ⊤ :=
have ∀ (h : is_inhabited u), ∃ (x : u), ⊤ :=
  take (h : is_inhabited u),
  @is_inhabited.inhabited[h],
obtain (indefinite_description : is_inhabited u → u), ∀ h, ⊤ := ac «∀ (h : is_inhabited u), ∃ (x : u), ⊤»,
@exists.intro[_, indefinite_description] true.intro

-- Introducing this constant restricts the class of models to toposes whose supports split.
-- Postulating split supports together with the internal axiom of choice, our logic becomes
-- precisely an internal logic of toposes satisfying the _external_ axiom of choice.
--
--    internal axiom of choice + split supports = external axiom of choice
--
-- Assuming IAC, the following are equivalent. E is a topos.
-- (a) Supports split in E.
-- (b) Supports split in E/X for each X ∈ E.
--
-- Proof:
--   For (a) => (b), take any object f ∈ E/X, where f : A → X in E.
--   f has a split support iff there exists a morphism from supp f to f.
--   We want to construct such a morphism.
--   supp f in E/X is given by the inclusion i : im f → X in E.
--   By external AC (which follows from IAC + SS) of C, we have a section
--   s : im f → A of an epi q : A → im f.
--   Since f s = i q s = i = supp f, s is a morphism in E/X from supp f to f.
-- QED.
--
-- This lemma is very important because the fact the properties of the ambient category are
-- inherited to its slices corresponds to that introducing a variable does not change the logic.
-- If we add locally defined types in the future, this lemma justifies the use of indefinite_description
-- applying to such types that may contain free (term) variables.
const indefinite_description.{u} : is_inhabited u → u

/-
 -  Hilbert's epsilon
 -/

-- Construct Hilbert's epsilon from (internal) axiom of choice and indefinite description.
-- A similar construction is found in arXiv:1603.00822.

structure some.singleton u := {
  const some : (u → Prop) → u
  axiom spec (P : u → Prop) : (∃ y, P y) → P (some P)
}

instance some.singleton.is_inhabited.{u} (h : is_inhabited u) : is_inhabited (some.singleton u) := {
  lemma inhabited : ∃ (x : some.singleton u), ⊤ :=
  obtain (ε : (u → Prop) → u), ∀ P, (∃ y, P y) → P (ε P) := some.exists @is_inhabited.inhabited[h],
  obtain (this : some.singleton u), ε = some.singleton.some this := @some.singleton.abs[ε] «∀ P, (∃ y, P y) → P (ε P)»,
  @exists.intro[_, this] true.intro
}

def some.{u} [has (is_inhabited u)] : (u → Prop) → u := some.singleton.some (indefinite_description (some.singleton.is_inhabited summon))
lemma some.spec.{u} [has (is_inhabited u)] (P : u → Prop) : (∃ y, P y) → P (some P) := @some.singleton.spec[_, P]

/-
 - Global choice
 -/

-- The global choice operator is an object-level function assigning for each type u the choice function.
-- This operator corresponds to external axiom of choice.
-- We could postulate this operator first and then derive axiom of choice and indefinite description,
-- but our choice is was to use two weaker primitives and combine them to construct the stronger operator.

instance global_choice.is_inhabited.{u} : is_inhabited (inhab u → u) := {
  lemma inhabited : ∃ (f : inhab u → u), ⊤ :=
  obtain (f : inhab u → u), choice f := choice.exists,
  @exists.intro[_, f] true.intro
}

class instance global_choice.has.is_inhabited.{u} : has (is_inhabited (inhab u → u)) := {
  def summon : is_inhabited (inhab u → u) := global_choice.is_inhabited
}

def global_choice.{u} : inhab u → u := some choice
lemma global_choice.spec.{u} : choice global_choice.{u} := some.spec choice.exists

instance is_inhabited.inhab.{u} (h : is_inhabited u) : inhab u := {
  def rep : sub u := λ x, ⊤
  lemma inhabited : ∃ x, x ∈ rep := @is_inhabited.inhabited[h]
}

def indefinite_description_from_global_choice.{u} : is_inhabited u → u := λ h, global_choice (is_inhabited.inhab h)

lemma ac_from_global_choice.{u, v} (R : u → v → Prop) : (∀ x, ∃ y, R x y) → ∃ f, ∀ x, R x (f x) := {
  assume ∀ x, ∃ y, R x y,
  have ∀ x, ∃! (h : inhab v), R x = inhab.rep h :=
    take (x : u),
    -- FIXME: the unifier could not synthesize `R x`. Perhaps because it's a partially applied term?
    @inhab.uabs[R x] «∀ x, ∃ y, R x y»[x],
  have ∃! (f : u → inhab v), ∀ x, R x = inhab.rep (f x) :=
    auc «∀ x, ∃! (h : inhab v), R x = inhab.rep h»,
  obtain (f : u → inhab v), ∀ x, R x = inhab.rep (f x) :=
    uexists.exists «∃! (f : u → inhab v), ∀ x, R x = inhab.rep (f x)»,
  exists.intro
    (take (x : u),
    have inhab.rep (f x) (global_choice (f x)) :=
      @global_choice.spec[f x],
    eq.transport (eq.symm (eq.congr_fun «∀ x, R x = inhab.rep (f x)»[x])) «inhab.rep (f x) (global_choice (f x))»)
}


/-
 - natural numbers
 -/

-- The following declarations are introduced.
--
-- type const nat : Type
-- const nat.zero : nat
-- const nat.succ : nat → nat
-- axiom nat.ind : ∀ x, ∀ P, P nat.zero → (∀ n, P n → P (nat.succ n)) → P x
-- const nat.rec.{u} : nat → u → (nat → u → u) → u
-- axiom nat.zero.spec.{u} : nat.rec nat.zero = (λ x f, x)
-- axiom nat.succ.spec.{u} : ∀ n, nat.rec (nat.succ n) = λ x f, f n (nat.rec n x f)
--
-- Note that iota equations (rules in the form of `rec (ctor ..) = ..`) only hold propositionally in our system.
-- This is not a theoretical limitation but a measure to reduce the search space the higher-order unifier runs on.
-- If this limitation is too restrictive, please report us.
--
-- Any topos with a natural number object is a model of W-types, hence supports general inductive types.
-- [Moerdijk & Palmgren, '00]
type inductive nat
| zero : nat
| succ : nat → nat

-- type const nat : Type
-- const nat.zero : nat
-- const nat.succ : nat → nat
-- axiom nat.ind : ∀ n, ∀ P, P nat.zero → (∀ n, P n → P (nat.succ n)) → P n
-- axiom nat.zero_ne_succ : ∀ n, ¬(nat.zero = nat.succ n)
-- axiom nat.succ_inj : ∀ m n, nat.succ m = nat.succ n → m = n

def zero : nat := nat.zero
def succ : nat → nat := nat.succ

inductive nat.rec.graph.{u} (z : u) (f : nat → u → u) : nat → u → Prop
| zero : nat.rec.graph zero z
| succ (n : nat) (y : u) : nat.rec.graph n y → nat.rec.graph (succ n) (f n y)

-- nat.rec.graph.ind.{u} : ∀ z f n x P, nat.rec.graph z f n x → P zero z → (∀ m y, nat.rec.graph z f m y → P m y → P (succ m) (f m y)) → P n x

lemma nat.rec.exists.{u} (n : nat) (z : u) (f : nat → u → u) : ∃ a, nat.rec.graph z f n a :=
nat.ind
  (exists.intro nat.rec.graph.zero)
  (take (n : nat),
    assume ∃ a, nat.rec.graph z f n a,
    obtain (a : u), nat.rec.graph z f n a := «∃ a, nat.rec.graph z f n a»,
    have nat.rec.graph z f (succ n) (f n a) := @nat.rec.graph.succ[z, f, n, a] «nat.rec.graph z f n a»,
    have ∃ a, nat.rec.graph z f (succ n) a := @exists.intro[_, f n a] «nat.rec.graph z f (succ n) (f n a)»,
    «∃ a, nat.rec.graph z f (succ n) a»)

/-
lemma nat.rec.graph.at_zero.{u} (z : u) (f : nat → u → u) (a : u) : nat.rec.graph z f zero a → a = z :=
assume nat.rec.graph z f zero a,
@nat.rec.graph.ind[_, _, _, _, λ m b, m = zero → b = z ∧ (∃ k, m = succ k) → ⊤] «nat.rec.graph z f zero a»
  (and.intro
    (assume zero = zero,
     eq.refl)
    (assume ∃ k, zero = succ k,
     absurd nat.zero_ne_succ (eq.congr_arg nat.succ (eq.symm «zero = succ k»))))
  (take (n : nat),
   take (y : u),
    assume nat.rec.graph z f n y,
    assume y = z,
    absurd nat.zero_ne_succ (eq.congr_arg nat.succ (eq.symm «zero = succ n»)))

lemma nat.rec.graph.functional.{u} (z : u) (f : nat → u → u) : functional (nat.rec.graph z f) :=
take (n : nat),
take (a₁ a₂ : u),
assume nat.rec.graph z f n a₁,
assume nat.rec.graph z f n a₂,
nat.rec.graph.ind «nat.rec.graph z f n a₁»
  (nat.rec.graph.ind «nat.rec.graph z f n a₂»
    eq.refl
    (take (m : nat),
     take (y : u),
     assume nat.rec.graph z f m y,
     assume a₁ = y,
     ))
  (take (n : nat),
    assume nat.rec.graph z f n a₁,
    assume IH,
    assume nat.rec.graph.succ n a₂,
    have a₁ = a₂ := IH «nat.rec.graph z f n a₂»,
    eq.congr_arg (f n) «a₁ = a₂»)
-/

-- TODO: type ℕ := nat

def nat.add (n m : ℕ) : ℕ := nat.rec n m (λ p, succ)
def nat.mul (n m : ℕ) : ℕ := nat.rec n zero (λ p, nat.add m)

class instance nat.has_plus : has_plus ℕ := {
  def plus : ℕ → ℕ → ℕ := nat.add
}

class instance nat.has_ast : has_ast ℕ := {
  def ast : ℕ → ℕ → ℕ := nat.mul
}

def bit0 (n : ℕ) : ℕ := n + n
def bit1 (n : ℕ) : ℕ := succ (bit0 n)

-- def nat.pred (n : ℕ) : ℕ := nat.rec zero zero (λ p, p)
-- def nat.pred (n : ℕ) : ℕ := nat.rec zero zero (λ p _, p)
def nat.pred (n : ℕ) : ℕ := nat.rec zero zero (λ p k, p)
def nat.sub (n m : ℕ) : ℕ := nat.rec m n (λ p k, nat.pred k)

inductive nat.le (n : ℕ) : ℕ → Prop
| refl : nat.le n
| step (m : ℕ) : nat.le m → nat.le (succ m)

def nat.divides (a b : ℕ) : Prop := ∃ k, b = a * k

/-
 - basic inductive types
 -/

-- TODO
-- one may write like
--
--  type inductive prod (u v : Type) : Type
--  | pair (fst : u) (snd : v) : prod
--
type inductive unit
| star : unit

-- type inductive sum u v
-- | inl : u → sum
-- | inr : v → sum

-- type inductive empty

type inductive list u
| nil : list
| cons : u → list → list

type inductive option u
| none : option
| some : u → option

type inductive ord
| zero : ord
| succ : ord → ord
| limit : (nat → ord) → ord

type inductive bin_tree u
| empty : bin_tree
| leaf : u → bin_tree
| node : bin_tree → bin_tree → bin_tree

def nil.{u} : list u := list.nil
def cons.{u} (x : u) (l : list u) : list u := list.cons x l

def functional.{u, v} (R : u → v → Prop) : Prop := ∀ x a₁ a₂, R x a₁ → R x a₂ → a₁ = a₂

-- acc R x :↔ x is in the well-founded part of R
inductive acc.{u} (R : u → u → Prop) : u → Prop
| intro (x : u) : (∀ y, R y x → acc y) → acc x

def well_founded.{u} (R : u → u → Prop) : Prop := ∀ x, acc R x

lemma wf_induction.{u} (R : u → u → Prop) (P : u → Prop) : well_founded R → (∀ x, (∀ y, R y x → P y) → P x) → ∀ x, P x :=
assume well_founded R,
assume ∀ x, (∀ y, R y x → P y) → P x,
take (x : u),
have acc R x := «well_founded R»[x],
@acc.ind[R, x, P] «acc R x»
  -- TODO: bug: cannot use x as the name of the bound variable here
  (take (x_ : u),
   assume ∀ y, R y x_ → acc R y,
   assume ∀ y, R y x_ → P y,
   «∀ x, (∀ y, R y x → P y) → P x»[x_] «∀ y, R y x_ → P y»)

structure W.el u v := {
  -- polynomial
  const f : u → v
  const tree : list u → v → Prop
  axiom root : ∃ a, tree nil a
  axiom branch (l : list u) (a : v) (b : u) : tree l a → f b = a → ∃ a₀, tree (cons b l) a₀
  axiom prefix_closed (l : list u) (x : u) (a : v) : tree (cons x l) a → tree l (f x)
  axiom functional : functional tree
  axiom well_founded : well_founded (λ (p₁ p₂ : list u × v), tree (fst p₁) (snd p₁) ∧ tree (fst p₂) (snd p₂) ∧ ∃ l a, fst p₂ = cons a l ∧ fst p₁ = l ∧ snd p₂ = f a)
}

-- type infixr × : 35

local type const u v

-- TODO: use namespace
def star : unit := unit.star
-- def inl : u → sum u v := sum.inl
-- def inr : v → sum u v := sum.inr
def none : option u := option.none
-- def some : u → option u := option.some

lemma unit.eta_expand (x : unit) : x = star :=
unit.ind eq.refl

lemma unit.eta_reduce (x : unit) : star = x :=
eq.symm unit.eta_expand

lemma unit_ext (x₁ x₂ : unit) : x₁ = x₂ :=
eq.trans unit.eta_expand unit.eta_reduce

/-
 - (some) algebras
 -/

structure monoid u := {
  const mult : u → u → u
  const unit : u
  axiom assoc (x₁ x₂ x₃ : u) : mult (mult x₁ x₂) x₃ = mult x₁ (mult x₂ x₃)
  axiom left_unit (x : u) : mult unit x = x
  axiom right_unit (x : u) : mult x unit = x
}

def mult.{u} : monoid u → u → u → u := monoid.mult
def unit.{u} : monoid u → u := monoid.unit

def interchange.{u} (m₁ m₂ : monoid u) : Prop := ∀ a b c d, mult m₁ (mult m₂ a b) (mult m₂ c d) = mult m₂ (mult m₁ a c) (mult m₁ b d)

lemma interchange.equates_unit.{u} (m₁ m₂ : monoid u) : interchange m₁ m₂ → unit m₁ = unit m₂ :=
assume interchange m₁ m₂,
calc unit m₁ = mult m₁ (unit m₁) (unit m₁)                                         := eq.symm monoid.left_unit
         ... = mult m₁ (mult m₂ (unit m₂) (unit m₁)) (unit m₁)                     := eq.ap (eq.symm monoid.left_unit)
         ... = mult m₁ (mult m₂ (unit m₂) (unit m₁)) (mult m₂ (unit m₁) (unit m₂)) := eq.ap (eq.symm monoid.right_unit)
         ... = mult m₂ (mult m₁ (unit m₂) (unit m₁)) (mult m₁ (unit m₁) (unit m₂)) := «interchange m₁ m₂»[_, _, _, _]
         ... = mult m₂ (unit m₂) (mult m₁ (unit m₁) (unit m₂))                     := eq.ap monoid.right_unit
         ... = mult m₂ (unit m₂) (unit m₂)                                         := eq.ap monoid.left_unit
         ... = unit m₂                                                             := eq.ap monoid.right_unit

lemma interchange.equates_mult.{u} (m₁ m₂ : monoid u) : interchange m₁ m₂ → mult m₁ = mult m₂ :=
assume interchange m₁ m₂,
have ∀ a b, mult m₁ a b = mult m₂ a b :=
  take (a : u),
  take (b : u),
  calc mult m₁ a b = mult m₁ (mult m₂ a (unit m₂)) b                     := eq.ap (eq.symm monoid.right_unit)
               ... = mult m₁ (mult m₂ a (unit m₂)) (mult m₂ (unit m₂) b) := eq.ap (eq.symm monoid.left_unit)
               ... = mult m₂ (mult m₁ a (unit m₂)) (mult m₁ (unit m₂) b) := «interchange m₁ m₂»[_, _, _, _]
               ... = mult m₂ (mult m₁ a (unit m₁)) (mult m₁ (unit m₂) b) := eq.ap (eq.symm (interchange.equates_unit «interchange m₁ m₂»))
               ... = mult m₂ (mult m₁ a (unit m₁)) (mult m₁ (unit m₁) b) := eq.ap (eq.symm (interchange.equates_unit «interchange m₁ m₂»))
               ... = mult m₂ a (mult m₁ (unit m₁) b)                     := eq.ap monoid.right_unit
               ... = mult m₂ a b                                         := eq.ap monoid.left_unit,
-- FIXME: remove @ from fun_ext after the bug in the unifier is fixed.
@fun_ext[mult m₁, mult m₂] (take (a : u), @fun_ext[mult m₁ a, mult m₂ a] «∀ a b, mult m₁ a b = mult m₂ a b»[a])

lemma eckmann_hilton.{u} (m₁ m₂ : monoid u) : interchange m₁ m₂ → m₁ = m₂ :=
assume interchange m₁ m₂,
monoid.ext (interchange.equates_mult «interchange m₁ m₂») (interchange.equates_unit «interchange m₁ m₂»)

/-
structure monoid.hom u v [has (monoid u)] [has (monoid v)] := {
  const f : u → v
  axiom homomorphic (x₁ x₂ : u) : mult (f x₁) (f x₂) = f (mult x₁ x₂)
}
-/

inductive topology.{u} (subbase : sub (sub u)) : sub (sub u)
| subbase (x : sub u) : x ∈ subbase → topology x
| univ : topology univ
| inter (x y : sub u) : topology (x ∩ y)
| union (A : sub (sub u)) : (∀ a, a ∈ A → topology a) → topology (bigcup A)

structure space u := {
  const subbase : sub (sub u)
}

instance space.mk.{u} (subbase : sub (sub u)) : space u := {
  def subbase : sub (sub u) := subbase
}

def space.open.{u} (X : space u) (S : sub u) : Prop := topology (space.subbase X) S

structure complete_lattice u := {
  const Meet : sub u → u
  const Join : sub u → u
}

def complete_lattice.meet.{u} (L : complete_lattice u) (x y : u) : u :=
complete_lattice.Meet L (λ z, z = x ∨ z = y)

def complete_lattice.join.{u} (L : complete_lattice u) (x y : u) : u :=
complete_lattice.Join L (λ z, z = x ∨ z = y)

def complete_lattice.top.{u} (L : complete_lattice u) : u :=
complete_lattice.Meet L ∅

def complete_lattice.bot.{u} (L : complete_lattice u) : u :=
complete_lattice.Join L ∅

def complete_lattice.le.{u} (L : complete_lattice u) (x y : u) : Prop :=
x = complete_lattice.meet L x y

class instance complete_lattice.has_vee.{u} [has (complete_lattice u)] : has_vee u := {
  def vee : u → u → u := complete_lattice.meet summon
}

class instance complete_lattice.has_wedge.{u} [has (complete_lattice u)] : has_wedge u := {
  def wedge : u → u → u := complete_lattice.meet summon
}

class instance complete_lattice.has_top.{u} [has (complete_lattice u)] : has_top u := {
  def top : u := complete_lattice.top summon
}

class instance complete_lattice.has_bot.{u} [has (complete_lattice u)] : has_bot u := {
  def bot : u := complete_lattice.bot summon
}

class instance complete_lattice.has_le.{u} [has (complete_lattice u)] : has_le u := {
  def le : u → u → Prop := complete_lattice.le summon
}

-- TODO: add notations
def Meet.{u} [has (complete_lattice u)] : sub u → u := complete_lattice.Meet summon
def Join.{u} [has (complete_lattice u)] : sub u → u := complete_lattice.Join summon

-- def monotone.{u, v} [has_le u] [has_le v] (f : u → v) : Prop := ∀ x y, x ≤ y → f x ≤ f y

def lfp.{u} [has (complete_lattice u)] (f : u → u) : u := Meet { x | f x ≤ x }
def gfp.{u} [has (complete_lattice u)] (f : u → u) : u := Join { x | x ≤ f x }
