# Design: Remove `structure.rec` and make fields primitive

## Summary
Remove the recursor generated by top-level `structure` declarations. Structure field projections become primitive constants (no delta definition in terms of `rec`). Instance specifications will switch from rec-based equations to per-field spec axioms.

## Motivation
`structure.rec` is only used to define projections via delta. This creates a dependency on delta expansion for field reduction and complicates any future local-structure work. The code already has a TODO to replace `structure.rec` with direct field projections. This change removes the recursor and makes projections primitive, with explicit axioms to connect instances to their fields.

## Goals
- Stop generating `Foo.rec` for `structure Foo`.
- Stop defining `Foo.field` via delta to `Foo.rec`.
- Preserve `Foo.abs` and `Foo.ext` axioms (still in terms of fields).
- Replace instance rec-spec axioms with per-field spec axioms.
- Keep existing inductive `rec` rules unchanged.

## Non-goals
- Do not change inductive recursors (`inductive` rec remains as-is).
- Do not change class structures or class instances.
- Do not change the proof kernel beyond environment contents.

## Current behavior (baseline)
For `structure Foo := { const f : T; axiom p : ... }`, the command
- defines `Foo` as a type constant,
- defines a recursor `Foo.rec`,
- defines `Foo.f` as a constant with a delta definition using `Foo.rec`,
- defines `Foo.p` (axiom field) by substituting `Foo.f this`,
- adds `Foo.abs` and `Foo.ext` axioms.

For `instance Bar : Foo := { def f := ...; lemma p := ... }`, the command
- defines `Bar.f` and `Bar.p` per field,
- defines `Bar` as a constant of type `Foo`,
- adds an axiom `Bar.rec` relating `Foo.rec (Bar ...)` to the field values.

## Proposed behavior
### Structure declarations
- Do **not** generate `Foo.rec`.
- Define `Foo.f` as a constant with no delta definition.
- Keep `Foo.abs` and `Foo.ext` axioms as-is, using `Foo.f` projections.
- Keep namespace reservations for `abs`/`ext`. Decide whether to keep `rec` reserved (see Open Questions).

### Instance declarations (for structures)
Replace the single rec-spec axiom with **per-field spec axioms** for const fields.

For each const field `f`, generate:
```
axiom Bar.f.spec : Foo.f (Bar params) = Bar.f params
```
- The axiom name should be `Bar.f.spec` (i.e. `instance_name.extend(field_name).extend("spec")`).
- This keeps rewriting local to each field and avoids a monolithic conjunction.
- Axiom fields (lemmas) are unchanged.

This restores the main usability of the old rec-spec: users can rewrite `Foo.f (Bar ...)` into the concrete definition `Bar.f ...` when needed.

### Concrete example: `bool`
The comments in `src/main.shari` describe the current desugaring using `bool.rec`. Under this change, it becomes:

Structure:
```
type const bool : Type
const bool.rep : bool -> Prop
axiom bool.spec (this : bool) : bool.rep this = ⊤ ∨ bool.rep this = ⊥
axiom bool.abs (rep : Prop) : rep = ⊤ ∨ rep = ⊥ -> ∃ this, rep = bool.rep this
axiom bool.ext (this1 this2 : bool) : bool.rep this1 = bool.rep this2 -> this1 = this2
```

Instance `bool.tt`:
```
def bool.tt.rep : Prop := ⊤
lemma bool.tt.spec : bool.tt.rep = ⊤ ∨ bool.tt.rep = ⊥ := ...
const bool.tt : bool
axiom bool.tt.rep.spec : bool.rep bool.tt = bool.tt.rep
```

Instance `bool.ff`:
```
def bool.ff.rep : Prop := ⊥
lemma bool.ff.spec : bool.ff.rep = ⊤ ∨ bool.ff.rep = ⊥ := ...
const bool.ff : bool
axiom bool.ff.rep.spec : bool.rep bool.ff = bool.ff.rep
```

Rewriting `bool.rep tt` now uses `bool.tt.rep.spec` instead of `bool.tt.rec`.

## Semantics
- `Foo.f` is an opaque constant (no definitional unfolding).
- Definitional equality no longer reduces `Foo.f` to a `Foo.rec` application.
- Instance field specs provide propositional rewriting where needed.
- `Foo.abs` and `Foo.ext` remain the only structure-wide axioms.

## Impact and compatibility
- Proofs that relied on definitional unfolding of `Foo.f` will need explicit rewriting using the new `Bar.f.spec` axioms.
- Log output and snapshot tests will change (no `Foo.rec` or `Bar.rec` entries).
- Inductive recursors are unaffected.

## Implementation plan
1) **Cmd: structure generation** (`src/cmd.rs`)
- In `run_structure_cmd`, remove:
  - `rec_name` definition/check.
  - `Foo.rec` const creation.
  - `add_delta` calls that define `Foo.field` via `Foo.rec`.
- Keep `Foo.field` const declarations and all `abs`/`ext` logic.

2) **Cmd: instance generation** (`src/cmd.rs`)
- Remove `Bar.rec` axiom generation.
- Add per-field spec axioms for const fields:
  - Build `Foo.f (Bar params)` on the LHS.
  - Build `Bar.f params` on the RHS.
  - Add axiom named `Bar.f.spec`.
- Ensure name collisions are checked for each `Bar.f.spec`.

3) **Docs / samples**
- Update `src/main.shari` comments that describe structure rec.
- Update any documentation that mentions `structure.rec`.

4) **Tests / snapshots**
- Update snapshot logs to reflect removal of `*.rec` entries for structures/instances.
- Add or adjust tests that use `Bar.f.spec` for rewriting.

## Open questions
- Should `rec` remain reserved in structure namespaces even though it is no longer generated?
- Should per-field spec axioms be named `Bar.f.spec` or `Bar.f.def`?
- Should we also add a combined spec axiom for convenience (likely no)?
